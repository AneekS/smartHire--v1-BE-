===== FILE: ./.env.example =====
# Server
NODE_ENV=development
PORT=3000
FRONTEND_URL=http://localhost:5173
CORS_ORIGINS=http://localhost:5173,https://app.smarthire.ai

# Database
DATABASE_URL=postgresql://smarthire:dev_password@localhost:5432/smarthire

# Redis
REDIS_URL=redis://localhost:6379

# JWT
JWT_SECRET=your-super-secret-key-min-32-characters-long
JWT_EXPIRES_IN=15m
REFRESH_TOKEN_EXPIRES_IN=30d

# AWS S3 / Cloudflare R2
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=ap-south-1
S3_BUCKET=

# OpenAI
OPENAI_API_KEY=sk-
OPENAI_PARSE_MODEL=gpt-4o-mini
OPENAI_SUGGEST_MODEL=gpt-4o

# Email
RESEND_API_KEY=

# Monitoring
SENTRY_DSN=

# Secret for internal service bypass of scoring rate limits (min 32 chars)
INTERNAL_SERVICE_SECRET=change-me-to-a-random-32-char-string


===== FILE: ./package.json =====
{
  "name": "smarthire-api",
  "version": "1.0.0",
  "description": "SmartHire AI Backend â€” Modular Monolith",
  "main": "dist/app.js",
  "scripts": {
    "dev": "tsx watch src/app.ts",
    "dev:api": "tsx watch src/app.ts",
    "dev:worker": "tsx watch src/worker.ts",
    "dev:all": "concurrently \"npm run dev:api\" \"npm run dev:worker\"",
    "build": "tsc --project tsconfig.json",
    "start": "node -r tsconfig-paths/register dist/app.js",
    "worker:dev": "tsx watch src/worker.ts",
    "worker:start": "node -r tsconfig-paths/register dist/worker.js",
    "db:migrate": "prisma migrate deploy",
    "db:seed": "tsx prisma/seed.ts",
    "db:studio": "prisma studio",
    "test": "vitest",
    "typecheck": "tsc --noEmit",
    "scoring:benchmark": "npx tsx src/modules/scoring/scoring.benchmark.ts",
    "test:scoring": "vitest run src/modules/scoring/__tests__"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.624.0",
    "@aws-sdk/s3-request-presigner": "^3.624.0",
    "@bull-board/api": "^5.22.0",
    "@bull-board/fastify": "^5.22.0",
    "@fastify/cors": "^9.0.1",
    "@fastify/helmet": "^11.1.1",
    "@fastify/multipart": "^8.3.0",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/swagger": "^8.14.0",
    "@prisma/client": "^5.17.0",
    "@sentry/node": "^8.26.0",
    "bcrypt": "^5.1.1",
    "bullmq": "^5.12.0",
    "dotenv": "^16.4.5",
    "fastify": "^4.28.0",
    "fastify-plugin": "^4.5.1",
    "fastify-type-provider-zod": "^2.0.0",
    "file-type": "^19.5.0",
    "ioredis": "^5.4.1",
    "jsonwebtoken": "^9.0.2",
    "lru-cache": "^10.0.0",
    "mammoth": "^1.8.0",
    "openai": "^4.55.0",
    "pdf-parse": "^1.1.1",
    "prisma": "^5.17.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/node": "^22.5.0",
    "@types/pdf-parse": "^1.1.4",
    "concurrently": "^8.2.2",
    "ioredis-mock": "^8.0.0",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.19.0",
    "typescript": "^5.9.3",
    "vitest": "^2.0.5"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "engines": {
    "node": ">=20"
  }
}


===== FILE: ./prisma/schema.prisma =====
// SmartHire AI â€” Prisma Schema
// PostgreSQL 15

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUTH & CANDIDATES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Candidate {
  id                String    @id @default(cuid())
  email             String    @unique
  phone             String?   @unique
  passwordHash      String?
  oauthProvider     String?
  oauthId           String?
  isEmailVerified   Boolean   @default(false)
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  profile           CandidateProfile?
  resumes           Resume[]
  applications      Application[]
  refreshTokens      RefreshToken[]
  skillScores        CandidateSkill[]
  reputationScore   ReputationScore?
  notifications     Notification[]

  @@map("candidates")
}

model RefreshToken {
  id          String    @id @default(cuid())
  tokenHash   String    @unique
  candidateId String
  candidate   Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  isRevoked   Boolean   @default(false)

  @@index([candidateId])
  @@index([tokenHash])
  @@map("refresh_tokens")
}

model CandidateProfile {
  id                  String    @id @default(cuid())
  candidateId         String    @unique
  candidate           Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)

  fullName            String
  avatarUrl           String?
  city                String?
  state               String?
  linkedinUrl         String?
  githubUrl           String?
  portfolioUrl        String?

  preferredRoles      String[]
  preferredLocations  String[]
  salaryExpectation   Int?
  workType            String?
  experienceLevel     String?

  education           Json?

  completionScore     Int       @default(0)
  isPublic            Boolean   @default(true)
  showReputationScore Boolean   @default(false)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@map("candidate_profiles")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RESUME
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Resume {
  id              String      @id @default(cuid())
  candidateId     String
  candidate       Candidate   @relation(fields: [candidateId], references: [id], onDelete: Cascade)

  fileName        String
  fileUrl         String
  fileType        String
  fileSize        Int
  fileHash        String?
  version         Int         @default(1)
  isActive        Boolean     @default(true)

  parseStatus     ParseStatus @default(PENDING)
  parseError      String?
  parsedAt        DateTime?

  parsedData      Json?
  extractedSkills String[]
  yearsExperience Float?
  educationLevel  String?

  atsScore        Int?

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  suggestions     ResumeSuggestion[]
  jobAtsScores    JobAtsScore[]

  @@index([candidateId])
  @@index([parseStatus])
  @@index([candidateId, fileHash])
  @@map("resumes")
}

enum ParseStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model ResumeSuggestion {
  id          String    @id @default(cuid())
  resumeId    String
  resume      Resume    @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  jobId       String?

  type        String
  severity    String
  section     String?
  original    String?
  suggested   String?
  reason      String
  isApplied   Boolean   @default(false)

  createdAt   DateTime  @default(now())

  @@index([resumeId])
  @@index([jobId])
  @@map("resume_suggestions")
}

model JobAtsScore {
  id              String    @id @default(cuid())
  resumeId        String
  resume          Resume    @relation(fields: [resumeId], references: [id])
  jobId           String
  job             Job       @relation(fields: [jobId], references: [id])

  score           Int
  matchedKeywords String[]
  missingKeywords String[]
  breakdown       Json?

  computedAt      DateTime  @default(now())

  @@unique([resumeId, jobId])
  @@map("job_ats_scores")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SKILLS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Skill {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  category    String
  aliases     String[]

  candidateSkills   CandidateSkill[]
  jobRequiredSkills JobSkill[]

  @@map("skills")
}

model CandidateSkill {
  id          String    @id @default(cuid())
  candidateId String
  candidate   Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  skillId     String
  skill       Skill     @relation(fields: [skillId], references: [id])

  proficiency Int       @default(50)
  source      String

  updatedAt   DateTime  @updatedAt

  @@unique([candidateId, skillId])
  @@index([candidateId])
  @@index([skillId])
  @@map("candidate_skills")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// JOBS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Job {
  id                String    @id @default(cuid())
  title             String
  company           String
  companyLogoUrl    String?
  location          String
  locationType      String
  salaryMin         Int?
  salaryMax         Int?
  experienceMin     Float
  experienceMax     Float
  description       String
  shortDescription  String?
  keywords          String[]
  status            JobStatus @default(ACTIVE)
  postedBy          String?

  publishedAt       DateTime  @default(now())
  expiresAt         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  requiredSkills    JobSkill[]
  applications      Application[]
  atsScores         JobAtsScore[]

  @@index([status])
  @@index([location])
  @@map("jobs")
}

enum JobStatus {
  ACTIVE
  PAUSED
  CLOSED
  DRAFT
}

model JobSkill {
  id          String    @id @default(cuid())
  jobId       String
  job         Job       @relation(fields: [jobId], references: [id])
  skillId     String
  skill       Skill     @relation(fields: [skillId], references: [id])
  isRequired  Boolean   @default(true)
  weight      Int       @default(1)

  @@unique([jobId, skillId])
  @@map("job_skills")
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// APPLICATIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model Application {
  id          String    @id @default(cuid())
  candidateId String
  candidate   Candidate @relation(fields: [candidateId], references: [id])
  jobId       String
  job         Job       @relation(fields: [jobId], references: [id])
  resumeId    String

  status      AppStatus @default(APPLIED)

  appliedAt         DateTime  @default(now())
  reviewedAt        DateTime?
  interviewedAt    DateTime?
  offeredAt        DateTime?
  hiredAt          DateTime?
  rejectedAt       DateTime?

  notes             String?

  @@unique([candidateId, jobId])
  @@index([candidateId])
  @@index([candidateId, status])
  @@index([jobId])
  @@map("applications")
}

enum AppStatus {
  APPLIED
  UNDER_REVIEW
  INTERVIEW_SCHEDULED
  OFFER
  HIRED
  REJECTED
  WITHDRAWN
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REPUTATION & NOTIFICATIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

model ReputationScore {
  id                    String    @id @default(cuid())
  candidateId           String    @unique
  candidate             Candidate @relation(fields: [candidateId], references: [id])

  overallScore          Int       @default(0)
  interviewPerformance  Int       @default(0)
  responseRate           Int       @default(0)
  assessmentCompletion   Int       @default(0)
  profileCompleteness    Int       @default(0)

  lastCalculatedAt      DateTime  @default(now())

  @@map("reputation_scores")
}

model Notification {
  id          String    @id @default(cuid())
  candidateId String
  candidate   Candidate @relation(fields: [candidateId], references: [id])

  type        String
  title       String
  body        String
  data        Json?
  isRead      Boolean   @default(false)

  createdAt   DateTime  @default(now())

  @@index([candidateId, isRead])
  @@map("notifications")
}


===== FILE: ./prisma/seed.ts =====
import { PrismaClient } from '@prisma/client';
import { SKILL_TAXONOMY } from '../src/shared/constants/skill-taxonomy';

const prisma = new PrismaClient();

async function main() {
  console.log('Seeding skill taxonomy...');

  for (const skill of SKILL_TAXONOMY) {
    await prisma.skill.upsert({
      where: { slug: skill.slug },
      update: { aliases: skill.aliases },
      create: skill,
    });
  }

  console.log(`Seeded ${SKILL_TAXONOMY.length} skills`);
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect());


===== FILE: ./smarthire-backend/.env.example =====
DATABASE_URL=postgresql://user:password@localhost:5432/smarthire
REDIS_URL=redis://localhost:6379
JWT_SECRET=supersecretjwt_32characters_minimum
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d
AWS_S3_BUCKET_NAME=mybucket
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=xxx
AWS_SECRET_ACCESS_KEY=xxx
INTERNAL_API_SECRET=supersecret_internal_32chars_minim
RESUME_PARSE_WEBHOOK_SECRET=supersecret_webhook_32chars_mini
NODE_ENV=development
PORT=4000
LOG_LEVEL=info
CORS_ALLOWED_ORIGINS=http://localhost:3000

===== FILE: ./smarthire-backend/package.json =====
{
  "name": "smarthire-backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "db:migrate": "prisma migrate deploy",
    "db:generate": "prisma generate",
    "db:studio": "prisma studio",
    "test": "jest --runInBand",
    "test:coverage": "jest --coverage",
    "lint": "tsc --noEmit"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/s3-request-presigner": "^3.0.0",
    "@prisma/client": "^5.0.0",
    "bullmq": "^5.0.0",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "express": "^4.18.0",
    "express-rate-limit": "^7.0.0",
    "helmet": "^7.0.0",
    "ioredis": "^5.3.0",
    "jsonwebtoken": "^9.0.0",
    "rate-limit-redis": "^4.0.0",
    "uuid": "^9.0.0",
    "winston": "^3.11.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/compression": "^1.7.0",
    "@types/cors": "^2.8.0",
    "@types/express": "^4.17.0",
    "@types/jest": "^29.0.0",
    "@types/jsonwebtoken": "^9.0.0",
    "@types/node": "^20.0.0",
    "@types/supertest": "^6.0.0",
    "@types/uuid": "^9.0.0",
    "jest": "^29.0.0",
    "prisma": "^5.0.0",
    "supertest": "^6.0.0",
    "ts-jest": "^29.0.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.0.0"
  }
}

===== FILE: ./smarthire-backend/prisma/schema.prisma =====
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [citext, pg_trgm, uuid_ossp]
}

enum ProfileVisibility {
  PUBLIC
  APPLIED_ONLY
  PRIVATE
}

enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
  FREELANCE
  INTERNSHIP
}

enum AvailabilityStatus {
  ACTIVELY_LOOKING
  OPEN_TO_OFFERS
  NOT_LOOKING
}

enum ResumeParseStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  USER_CONFIRMED
}

enum SkillProficiency {
  BEGINNER
  ELEMENTARY
  INTERMEDIATE
  ADVANCED
  EXPERT
}

model CandidateProfile {
  id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId                String    @unique @db.Uuid
  fullName              String    @db.VarChar(120)
  phoneCountryCode      String?   @db.VarChar(6)
  phoneNumber           String?   @db.VarChar(20)
  headline              String?   @db.VarChar(220)
  bio                   String?   @db.Text
  avatarUrl             String?   @db.Text
  locationCity          String?   @db.VarChar(100)
  locationState         String?   @db.VarChar(100)
  locationCountry       String?   @db.VarChar(100)  @default("IN")
  locationLatitude      Float?
  locationLongitude     Float?
  completenessScore     Int       @default(0)
  completenessBreakdown Json      @default("{}")
  isDeleted             Boolean   @default(false)
  deletedAt             DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  version               Int       @default(0)
  education             Education[]
  experience            WorkExperience[]
  skills                CandidateSkill[]
  careerIntent          CareerIntent?
  resumeVersions        ResumeVersion[]
  privacySettings       PrivacySettings?
  auditLogs             ProfileAuditLog[]

  @@index([userId])
  @@index([completenessScore])
  @@index([locationCountry, locationCity])
  @@index([isDeleted])
  @@map("candidate_profiles")
}

model Education {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId     String    @db.Uuid
  institution   String    @db.VarChar(200)
  degree        String    @db.VarChar(120)
  fieldOfStudy  String    @db.VarChar(120)
  startDate     DateTime  @db.Date
  endDate       DateTime? @db.Date
  isCurrent     Boolean   @default(false)
  grade         String?   @db.VarChar(20)
  description   String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  profile       CandidateProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@map("candidate_education")
}

model WorkExperience {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId       String    @db.Uuid
  company         String    @db.VarChar(200)
  role            String    @db.VarChar(150)
  employmentType  JobType   @default(FULL_TIME)
  startDate       DateTime  @db.Date
  endDate         DateTime? @db.Date
  isCurrent       Boolean   @default(false)
  location        String?   @db.VarChar(150)
  description     String?   @db.Text
  achievements    Json      @default("[]")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  profile         CandidateProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId])
  @@map("candidate_work_experience")
}

model SkillCategory {
  id     String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name   String  @unique @db.VarChar(80)
  slug   String  @unique @db.VarChar(80)
  skills Skill[]

  @@map("skill_categories")
}

model Skill {
  id              String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name            String         @unique @db.Citext
  slug            String         @unique @db.VarChar(100)
  categoryId      String         @db.Uuid
  aliases         String[]
  isVerifiable    Boolean        @default(false)
  category        SkillCategory  @relation(fields: [categoryId], references: [id])
  candidateSkills CandidateSkill[]

  @@index([categoryId])
  @@index([name])
  @@map("skills")
}

model CandidateSkill {
  id                  String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId           String           @db.Uuid
  skillId             String           @db.Uuid
  proficiency         SkillProficiency @default(INTERMEDIATE)
  yearsOfExp          Float            @default(0)
  isVerified          Boolean          @default(false)
  verifiedAt          DateTime?
  verificationSource  String?          @db.VarChar(100)
  endorsementCount    Int              @default(0)
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  profile             CandidateProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  skill               Skill            @relation(fields: [skillId], references: [id])

  @@unique([profileId, skillId])
  @@index([profileId])
  @@index([skillId])
  @@index([proficiency])
  @@index([isVerified])
  @@index([profileId, proficiency])
  @@map("candidate_skills")
}

model CareerIntent {
  id                  String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId           String             @unique @db.Uuid
  preferredRoles      String[]
  preferredLocations  String[]
  salaryMinMonthly    Int?
  salaryMaxMonthly    Int?
  salaryCurrency      String             @default("INR") @db.VarChar(5)
  jobTypes            JobType[]
  openToRelocation    Boolean            @default(false)
  availability        AvailabilityStatus @default(OPEN_TO_OFFERS)
  noticePeriodDays    Int?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  profile             CandidateProfile   @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([availability])
  @@index([openToRelocation])
  @@map("candidate_career_intent")
}

model ResumeVersion {
  id               String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId        String            @db.Uuid
  versionNumber    Int
  fileName         String            @db.VarChar(255)
  fileMimeType     String            @db.VarChar(80)
  fileSizeBytes    Int
  storageKey       String            @db.Text
  parseStatus      ResumeParseStatus @default(PENDING)
  parsedData       Json?
  isActive         Boolean           @default(true)
  userConfirmed    Boolean           @default(false)
  userConfirmedAt  DateTime?
  parseJobId       String?           @db.VarChar(100)
  parseFailReason  String?           @db.Text
  uploadedAt       DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  profile          CandidateProfile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, versionNumber])
  @@index([profileId, isActive])
  @@index([parseStatus])
  @@map("resume_versions")
}

model PrivacySettings {
  id                        String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId                 String            @unique @db.Uuid
  profileVisibility         ProfileVisibility @default(APPLIED_ONLY)
  allowRecruiterMessaging   Boolean           @default(true)
  hideFromCompanies         String[]
  gdprConsentGiven          Boolean           @default(false)
  gdprConsentAt             DateTime?
  marketingConsentGiven     Boolean           @default(false)
  dataRetentionOptOut       Boolean           @default(false)
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  profile                   CandidateProfile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("candidate_privacy_settings")
}

model ProfileAuditLog {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  profileId   String    @db.Uuid
  actorId     String    @db.Uuid
  actorRole   String    @db.VarChar(50)
  action      String    @db.VarChar(100)
  entityType  String    @db.VarChar(80)
  entityId    String?   @db.Uuid
  diff        Json?
  ipAddress   String?   @db.VarChar(45)
  userAgent   String?   @db.Text
  createdAt   DateTime  @default(now())
  profile     CandidateProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([profileId, createdAt])
  @@index([actorId])
  @@index([action])
  @@map("profile_audit_logs")
}


===== FILE: ./smarthire-backend/server.ts =====
import { app } from './src/app';
import { env } from './src/config/env';
import { logger } from './src/shared/utils/logger';
import { prisma } from './src/config/database';
import os from 'os';
import cluster from 'cluster';
import Redis from 'ioredis';

const redisClient = new Redis(env.REDIS_URL);

if (env.NODE_ENV === 'production' && cluster.isPrimary) {
  const cpus = os.cpus().length;
  for (let i = 0; i < cpus; i++) cluster.fork();
  cluster.on('exit', (worker, code, signal) => {
    logger.warn(`Worker ${worker.process.pid} died`);
    cluster.fork();
  });
} else {
  const server = app.listen(env.PORT, () => logger.info(`Server running on port ${env.PORT} - PID ${process.pid}`));

  async function gracefulShutdown(signal: string) {
    logger.info(`${signal} received â€” initiating graceful shutdown`);
    server.close(async (err: any) => {
      if (err) logger.error('Error during server close', { err });
      await prisma.$disconnect();
      await redisClient.quit();
      logger.info('Graceful shutdown complete');
      process.exit(err ? 1 : 0);
    });
    setTimeout(() => {
      logger.error('Forced shutdown after timeout');
      process.exit(1);
    }, 30000);
  }

  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
  process.on('SIGINT', () => gracefulShutdown('SIGINT'));
}


===== FILE: ./smarthire-backend/src/app.ts =====
import express, { Express, Request, Response } from 'express';
import helmet from 'helmet';
import cors from 'cors';
import compression from 'compression';
import { env } from './config/env';
import { requestIdMiddleware } from './middleware/requestId.middleware';
import { rateLimitMiddleware } from './middleware/rateLimit.middleware';
import { authMiddleware } from './middleware/auth.middleware';
import { rbacMiddleware } from './middleware/rbac.middleware';
import { internalAuthMiddleware } from './middleware/internalAuth.middleware';
import { errorMiddleware, notFoundMiddleware } from './middleware/error.middleware';
import { logger } from './shared/utils/logger';

// Routers
import { candidateProfileRouter } from './modules/candidate-profile/candidate-profile.routes';

export const app: Express = express();

app.use(requestIdMiddleware);
app.use(express.json({ limit: "50kb" }));
app.use(helmet());
app.use(cors({ origin: env.CORS_ALLOWED_ORIGINS_ARRAY }));
app.use(compression());
app.use((req, res, next) => {
  logger.info({ message: 'Incoming request', method: req.method, url: req.url, id: req.id });
  next();
});

// Health routes
app.get('/health', (req, res) => res.json({ success: true, data: { status: 'ok', timestamp: new Date().toISOString(), version: '1.0.0' } }));
app.get('/health/ready', async (req, res) => {
  // Try DB and Redis
  try {
    const { prisma } = require('./config/database');
    const Redis = require('ioredis');
    await prisma.$queryRaw`SELECT 1`;
    const redis = new Redis(env.REDIS_URL);
    await redis.ping();
    res.json({ status: 'ok', checks: { db: true, redis: true } });
  } catch (err) {
    res.status(503).json({ status: 'degraded', checks: { db: false, redis: false } });
  }
});
app.get('/health/live', (req, res) => res.sendStatus(200));

// API routes
app.use('/api/v1/candidates/profile', rateLimitMiddleware('candidate-api', 100, 60), authMiddleware, candidateProfileRouter);

// More routes dynamically added here for recruiters, admins, internal (mocked out due to size)
const recruiterRouter = express.Router();
app.use('/api/v1/recruiter', rateLimitMiddleware('recruiter-api', 200, 60), authMiddleware, rbacMiddleware(["RECRUITER", "ADMIN"]), recruiterRouter);

const adminRouter = express.Router();
app.use('/api/v1/admin', rateLimitMiddleware('admin-api', 100, 60), authMiddleware, rbacMiddleware(["ADMIN"]), adminRouter);

const internalRouter = express.Router();
app.use('/api/v1/internal', internalAuthMiddleware, internalRouter);

app.use(notFoundMiddleware);
app.use(errorMiddleware);


===== FILE: ./smarthire-backend/src/config/constants.ts =====
export const CONSTANTS = { MAX_LIMIT: 50 };

===== FILE: ./smarthire-backend/src/config/database.ts =====
import { PrismaClient } from '@prisma/client';
import { env } from './env';

export const prisma = new PrismaClient({
  datasources: {
    db: { url: env.DATABASE_URL.includes('pgbouncer=true') ? env.DATABASE_URL : `${env.DATABASE_URL}?pgbouncer=true&connection_limit=10&pool_timeout=30` }
  },
  log: env.NODE_ENV === 'development' ? ['query', 'warn', 'error'] : ['warn', 'error']
});


===== FILE: ./smarthire-backend/src/config/env.ts =====
import { z } from 'zod';
import dotenv from 'dotenv';
dotenv.config();

export const envSchema = z.object({
  DATABASE_URL: z.string(),
  REDIS_URL: z.string(),
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string(),
  JWT_REFRESH_EXPIRES_IN: z.string(),
  AWS_S3_BUCKET_NAME: z.string(),
  AWS_REGION: z.string(),
  AWS_ACCESS_KEY_ID: z.string(),
  AWS_SECRET_ACCESS_KEY: z.string(),
  INTERNAL_API_SECRET: z.string().min(32),
  RESUME_PARSE_WEBHOOK_SECRET: z.string().min(32),
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.coerce.number().default(4000),
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  CORS_ALLOWED_ORIGINS: z.string()
});
const parsed = envSchema.safeParse(process.env);
if (!parsed.success) {
  console.error("Missing/invalid exact environment variables:", parsed.error);
  process.exit(1);
}
export const env: any = {
  ...parsed.data,
  CORS_ALLOWED_ORIGINS_ARRAY: parsed.data.CORS_ALLOWED_ORIGINS.split(',').map((s: string) => s.trim())
};


===== FILE: ./smarthire-backend/src/jobs/profile-completeness.job.ts =====
import { Queue, Worker } from 'bullmq';
import { env } from '../config/env';
import { prisma } from '../config/database';
// Completeness recompute job
export const completenessQueue = new Queue('completeness', { connection: { url: env.REDIS_URL } });
export const completenessWorker = new Worker('completeness', async job => {
  // Recompute logic
}, { connection: { url: env.REDIS_URL } });


===== FILE: ./smarthire-backend/src/jobs/profile-gdpr-delete.job.ts =====
import { Queue, Worker } from 'bullmq';
import { env } from '../config/env';
import { prisma } from '../config/database';

export const gdprDeleteWorker = new Worker('gdpr-delete', async job => {
  const { profileId } = job.data;
  await prisma.$transaction(async (tx) => {
    await tx.candidateSkill.deleteMany({ where: { profileId } });
    await tx.education.deleteMany({ where: { profileId } });
    await tx.workExperience.deleteMany({ where: { profileId } });
    await tx.careerIntent.delete({ where: { profileId } }).catch(() => {});
    await tx.resumeVersion.deleteMany({ where: { profileId } });
    await tx.privacySettings.delete({ where: { profileId } }).catch(() => {});
    
    await tx.candidateProfile.update({
      where: { id: profileId },
      data: {
        fullName: "Deleted User",
        phoneCountryCode: null,
        phoneNumber: null,
        bio: null,
        avatarUrl: null,
        locationCity: null,
        locationLatitude: null,
        locationLongitude: null,
        isDeleted: true,
        deletedAt: new Date()
      }
    });
  });
}, { connection: { url: env.REDIS_URL } });


===== FILE: ./smarthire-backend/src/jobs/resume-parse-webhook.job.ts =====
// BullMQ job for handling retryable webhooks internally if needed


===== FILE: ./smarthire-backend/src/middleware/auth.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { env } from '../config/env';
import { UnauthorizedError } from '../shared/errors/UnauthorizedError';
import Redis from 'ioredis';
const redis = new Redis(env.REDIS_URL);
export const authMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) throw new UnauthorizedError();
    const token = authHeader.split(' ')[1];
    const isRevoked = await redis.get(`revoked:${token}`);
    if (isRevoked) throw new UnauthorizedError();
    const decoded: any = jwt.verify(token, env.JWT_SECRET);
    req.user = { userId: decoded.userId, role: decoded.role, email: decoded.email };
    next();
  } catch(err) { next(new UnauthorizedError('Invalid or expired token')); }
};

===== FILE: ./smarthire-backend/src/middleware/error.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../shared/errors/AppError';
import { logger } from '../shared/utils/logger';
export const errorMiddleware = (err: any, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof AppError) {
    if (err.statusCode === 500) logger.error('AppError (500)', { err });
    return res.status(err.statusCode).json({ success: false, error: { code: err.code, message: err.message, requestId: req.id, timestamp: new Date().toISOString(), details: err.details || [] } });
  }
  logger.error('Unhandled', { err });
  res.status(500).json({ success: false, error: { code: 'INTERNAL_SERVER_ERROR', message: 'Unexpected error', requestId: req.id, timestamp: new Date().toISOString(), details: [] } });
};
export const notFoundMiddleware = (req: Request, res: Response, next: NextFunction) => res.status(404).json({ success: false, error: { code: 'NOT_FOUND', message: 'Route not found', requestId: req.id, timestamp: new Date().toISOString(), details: []} });

===== FILE: ./smarthire-backend/src/middleware/internalAuth.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import crypto from 'crypto';
import { env } from '../config/env';
import { UnauthorizedError } from '../shared/errors/UnauthorizedError';
import { logger } from '../shared/utils/logger';

export const internalAuthMiddleware = (req: Request, res: Response, next: NextFunction) => {
    const token = req.headers['x-internal-token'];
    if (!token || typeof token !== 'string') {
        logger.warn('Internal webhook attempt without token', { ip: req.ip });
        return next(new UnauthorizedError('Missing internal token'));
    }

    try {
        const expected = Buffer.from(env.INTERNAL_API_SECRET);
        const provided = Buffer.from(token);
        if (provided.length !== expected.length || !crypto.timingSafeEqual(provided, expected)) {
            throw new Error('Mismatch');
        }
        next();
    } catch (err) {
        logger.warn('Invalid internal token attempt', { ip: req.ip });
        next(new UnauthorizedError('Invalid internal token'));
    }
};


===== FILE: ./smarthire-backend/src/middleware/rateLimit.middleware.ts =====
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';
import { env } from '../config/env';
import { RateLimitError } from '../shared/errors/RateLimitError';
const redis = new Redis(env.REDIS_URL);
export const rateLimitMiddleware = (key: string, maxRequests: number, windowSeconds: number) => rateLimit({
  store: new RedisStore({ sendCommand: async (...args: string[]) => { const res = await redis.call(args[0], ...args.slice(1)); return res as any; }, prefix: `rl:${key}:` }),
  windowMs: windowSeconds * 1000,
  max: maxRequests,
  handler: (req, res, next) => next(new RateLimitError()),
  keyGenerator: (req) => req.user?.userId || req.ip || 'unknown'
});

===== FILE: ./smarthire-backend/src/middleware/rbac.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { ForbiddenError } from '../shared/errors/ForbiddenError';
export const rbacMiddleware = (allowedRoles: string[]) => (req: Request, res: Response, next: NextFunction) => {
  if (!req.user || !allowedRoles.includes(req.user.role)) return next(new ForbiddenError('Insufficient permissions'));
  next();
};

===== FILE: ./smarthire-backend/src/middleware/requestId.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { v4 } from 'uuid';
export const requestIdMiddleware = (req: Request, res: Response, next: NextFunction) => {
  req.id = v4(); res.setHeader('X-Request-ID', req.id); next();
};

===== FILE: ./smarthire-backend/src/middleware/validate.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { ValidationError } from '../shared/errors/ValidationError';
export const validateMiddleware = (schema: any) => (req: Request, res: Response, next: NextFunction) => {
  try { req.body = schema.parse(req.body); next(); } catch(err: any) { next(new ValidationError(err.format())); }
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.controller.ts =====
import { Request, Response } from 'express';
import { CandidateProfileService } from './candidate-profile.service';
import { sendResponse } from '../../shared/utils/apiResponse';
const service = new CandidateProfileService();
export const createProfile = async (req: Request, res: Response) => {
  const data = await service.createProfile(req.user!.userId, req.body, req.id!);
  sendResponse(res, 201, data);
};
export const getMyProfile = async (req: Request, res: Response) => {
  const data = await service.getProfileById('my-id', req.user!.userId, req.user!.role); // placeholder fix
  sendResponse(res, 200, data);
};
export const getProfileById = async (req: Request, res: Response) => {
  const data = await service.getProfileById(req.params.profileId, req.user!.userId, req.user!.role);
  sendResponse(res, 200, data);
};
export const updateProfile = async (req: Request, res: Response) => {
  const data = await service.updateProfile('my-id', req.user!.userId, req.body, req.id!);
  sendResponse(res, 200, data);
};
export const softDeleteProfile = async (req: Request, res: Response) => {
  await service.softDeleteProfile('my-id', req.user!.userId, req.id!);
  sendResponse(res, 204, {});
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.events.ts =====
export const PROFILE_EVENTS = {
    PROFILE_CREATED: 'candidate.profile.created',
    PROFILE_UPDATED: 'candidate.profile.updated',
    PROFILE_DELETED: 'candidate.profile.deleted',
    SKILLS_UPDATED: 'candidate.profile.skills_updated',
    RESUME_PARSED: 'candidate.profile.resume_parsed',
    RESUME_CONFIRMED: 'candidate.profile.resume_confirmed',
    GDPR_DELETION_QUEUED: 'candidate.profile.gdpr_deletion_queued',
    PRIVACY_CHANGED: 'candidate.profile.privacy_changed',
} as const;

export type ProfileEventPayload = {
    eventType: string;
    profileId: string;
    userId: string;
    timestamp: string;
    correlationId: string;
    payload: Record<string, any>;
};


===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.repository.ts =====
import { prisma } from '../../config/database';
import { NotFoundError } from '../../shared/errors/NotFoundError';
import { ConflictError } from '../../shared/errors/ConflictError';
import { CursorPagination } from '../../shared/utils/pagination';

export class CandidateProfileRepository {
  async create(data: any, tx?: any) {
    const db = tx || prisma;
    return await db.candidateProfile.create({ data });
  }

  async findById(id: string, tx?: any) {
    const db = tx || prisma;
    const profile = await db.candidateProfile.findFirst({ where: { id, isDeleted: false } });
    if (!profile) throw new NotFoundError('Profile not found');
    return profile;
  }

  async findByUserId(userId: string, tx?: any) {
    const db = tx || prisma;
    return await db.candidateProfile.findFirst({ where: { userId, isDeleted: false } });
  }

  async update(id: string, data: any, expectedVersion: number, tx?: any) {
    const db = tx || prisma;
    const result = await db.candidateProfile.updateMany({
      where: { id, version: expectedVersion },
      data: { ...data, version: { increment: 1 } }
    });
    if (result.count === 0) throw new ConflictError('Profile was modified by another request. Refresh and retry.');
    return await this.findById(id, tx);
  }

  async softDelete(id: string, tx?: any) {
    const db = tx || prisma;
    await db.candidateProfile.update({
      where: { id },
      data: { isDeleted: true, deletedAt: new Date() }
    });
  }

  async findForRecruiter(filters: any, pagination: CursorPagination) {
    // simplified for script size
    return { items: [], meta: { limit: pagination.limit, hasNextPage: false, nextCursor: null } };
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.routes.ts =====
import { Router } from 'express';
import { rateLimitMiddleware } from '../../middleware/rateLimit.middleware';
import { validateMiddleware } from '../../middleware/validate.middleware';
import { rbacMiddleware } from '../../middleware/rbac.middleware';
import { asyncHandler } from '../../shared/utils/asyncHandler';
import * as controller from './candidate-profile.controller';
import { CreateProfileDto, UpdateProfileDto } from './candidate-profile.validator';

export const candidateProfileRouter = Router();

candidateProfileRouter.post('/', rateLimitMiddleware('candidate-api', 5, 60), validateMiddleware(CreateProfileDto), asyncHandler(controller.createProfile));
candidateProfileRouter.get('/', rateLimitMiddleware('candidate-api', 100, 60), asyncHandler(controller.getMyProfile));
candidateProfileRouter.get('/:profileId', rateLimitMiddleware('candidate-api', 100, 60), rbacMiddleware(["RECRUITER", "ADMIN"]), asyncHandler(controller.getProfileById));
candidateProfileRouter.patch('/', rateLimitMiddleware('candidate-api', 30, 60), validateMiddleware(UpdateProfileDto), asyncHandler(controller.updateProfile));
candidateProfileRouter.delete('/', rateLimitMiddleware('candidate-api', 5, 60), asyncHandler(controller.softDeleteProfile));


===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.service.ts =====
import { CandidateProfileRepository } from './candidate-profile.repository';
import { ConflictError } from '../../shared/errors/ConflictError';
import { ForbiddenError } from '../../shared/errors/ForbiddenError';
import { prisma } from '../../config/database';
import { PROFILE_EVENTS } from './candidate-profile.events';
import { events } from '../../shared/utils/events';

const repo = new CandidateProfileRepository();

export class CandidateProfileService {
  async createProfile(userId: string, dto: any, requestId: string) {
    const existing = await repo.findByUserId(userId);
    if (existing) throw new ConflictError('Profile already exists for this user');

    const result = await prisma.$transaction(async (tx) => {
      const p = await tx.candidateProfile.create({ data: { ...dto, userId } });
      await tx.privacySettings.create({ data: { profileId: p.id } });
      await tx.careerIntent.create({ data: { profileId: p.id } });
      return p;
    });

    result.completenessScore = this.computeCompleteness(result).score;
    await repo.update(result.id, { completenessScore: result.completenessScore }, result.version);

    events.emit(PROFILE_EVENTS.PROFILE_CREATED, {
      eventType: PROFILE_EVENTS.PROFILE_CREATED,
      profileId: result.id,
      userId,
      timestamp: new Date().toISOString(),
      correlationId: requestId,
      payload: { ...dto }
    });

    const { version, deletedAt, isDeleted, ...safe } = result as any;
    return safe;
  }

  async getProfileById(profileId: string, requestingUserId: string, role: string) {
    const p = await repo.findById(profileId);
    if (p.userId !== requestingUserId && role !== 'ADMIN') {
      const privacy = await prisma.privacySettings.findUnique({ where: { profileId } });
      if (privacy?.profileVisibility === 'PRIVATE') throw new ForbiddenError();
    }
    return p;
  }

  async updateProfile(profileId: string, userId: string, dto: any, requestId: string) {
    const profile = await repo.findById(profileId);
    if (profile.userId !== userId) throw new ForbiddenError('You do not have permission to modify this profile');

    const updated = await repo.update(profileId, dto, dto.version);
    updated.completenessScore = this.computeCompleteness(updated).score;
    // update score again
    await repo.update(profileId, { completenessScore: updated.completenessScore }, updated.version);

    events.emit(PROFILE_EVENTS.PROFILE_UPDATED, {
      eventType: PROFILE_EVENTS.PROFILE_UPDATED,
      profileId,
      userId,
      timestamp: new Date().toISOString(),
      correlationId: requestId,
      payload: { before: profile, after: updated }
    });
    return updated;
  }

  async softDeleteProfile(profileId: string, actorId: string, requestId: string) {
    const profile = await repo.findById(profileId);
    if (profile.userId !== actorId) throw new ForbiddenError('You do not have permission to modify this profile');

    await repo.softDelete(profileId);
    events.emit(PROFILE_EVENTS.PROFILE_DELETED, {
      eventType: PROFILE_EVENTS.PROFILE_DELETED,
      profileId,
      userId: actorId,
      timestamp: new Date().toISOString(),
      correlationId: requestId,
      payload: {}
    });
  }

  computeCompleteness(profile: any) {
    let score = 0;
    const breakdown: Record<string, number> = {};
    if (profile.fullName && profile.phoneCountryCode && profile.headline && profile.bio && profile.locationCity) {
      score += 25; breakdown.basic = 25;
    }
    return { score, breakdown };
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.types.ts =====
import { CandidateProfile, ProfileVisibility, JobType, AvailabilityStatus } from '@prisma/client';
export type CompleteProfileData = any; // simplified for script
export interface ProfileResponse extends CandidateProfile {}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/candidate-profile.validator.ts =====
import { z } from 'zod';

export const CreateProfileDto = z.object({
  fullName: z.string().trim().min(2).max(120),
  phoneCountryCode: z.string().trim().max(6).optional(),
  phoneNumber: z.string().trim().max(20).optional(),
  headline: z.string().trim().max(220).optional(),
  bio: z.string().trim().max(2000).optional(),
  locationCity: z.string().trim().max(100).optional(),
  locationState: z.string().trim().max(100).optional(),
  locationCountry: z.string().trim().length(2).default('IN')
});

export const UpdateProfileDto = CreateProfileDto.partial().extend({
  version: z.number().int().nonnegative()
});

export const RecruiterSearchDto = z.object({
  skillIds: z.array(z.string().uuid()).max(10).optional(),
  locations: z.array(z.string().trim()).max(5).optional(),
  availability: z.enum(['ACTIVELY_LOOKING', 'OPEN_TO_OFFERS', 'NOT_LOOKING']).optional(),
  minCompleteness: z.number().int().min(0).max(100).optional(),
  cursor: z.string().optional(),
  limit: z.number().int().min(1).max(50).default(20)
});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.controller.ts =====
import { Request, Response } from 'express';
import { CareerIntentService } from './career-intent.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new CareerIntentService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.repository.ts =====
import { prisma } from '../../../../config/database';
export class CareerIntentRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './career-intent.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const careerIntentRouter = Router();
careerIntentRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.service.ts =====
import { CareerIntentRepository } from './career-intent.repository';
export class CareerIntentService {
  repo = new CareerIntentRepository();
  async dummyLogic() { return true; }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/career-intent/career-intent.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.controller.ts =====
import { Request, Response } from 'express';
import { EducationService } from './education.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new EducationService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.repository.ts =====
import { prisma } from '../../../../config/database';
export class EducationRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './education.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const educationRouter = Router();
educationRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.service.ts =====
import { EducationRepository } from './education.repository';
export class EducationService {
  repo = new EducationRepository();
  async dummyLogic() { return true; }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/education/education.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.controller.ts =====
import { Request, Response } from 'express';
import { ExperienceService } from './experience.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new ExperienceService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.repository.ts =====
import { prisma } from '../../../../config/database';
export class ExperienceRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './experience.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const experienceRouter = Router();
experienceRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.service.ts =====
import { ExperienceRepository } from './experience.repository';
export class ExperienceService {
  repo = new ExperienceRepository();
  async dummyLogic() { return true; }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/experience/experience.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.controller.ts =====
import { Request, Response } from 'express';
import { PrivacyService } from './privacy.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new PrivacyService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.repository.ts =====
import { prisma } from '../../../../config/database';
export class PrivacyRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './privacy.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const privacyRouter = Router();
privacyRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.service.ts =====
import { prisma } from '../../../../config/database';
import { Queue } from 'bullmq';
import { env } from '../../../../config/env';
import { ForbiddenError } from '../../../../shared/errors/ForbiddenError';
import { events } from '../../../../shared/utils/events';
import { PROFILE_EVENTS } from '../../candidate-profile.events';

const gdprQueue = new Queue('gdpr-delete', { connection: { url: env.REDIS_URL } });

export class PrivacyService {
  async dummyLogic() { return true; }
  async getPrivacySettings(profileId: string, userId: string) {
    return prisma.privacySettings.findUnique({ where: { profileId } });
  }
  async updatePrivacySettings(profileId: string, userId: string, dto: any) {
    const existing = await prisma.privacySettings.findUnique({ where: { profileId } });
    if (!existing) throw new ForbiddenError();
    if (dto.gdprConsentGiven && !existing.gdprConsentGiven) dto.gdprConsentAt = new Date();
    const updated = await prisma.privacySettings.update({ where: { profileId }, data: dto });
    events.emit(PROFILE_EVENTS.PRIVACY_CHANGED, { eventType: PROFILE_EVENTS.PRIVACY_CHANGED, profileId, userId, timestamp: '', correlationId: '', payload: dto });
    return updated;
  }
  async initiateGDPRDeletion(profileId: string, requestedByUserId: string) {
    const job = await gdprQueue.add('delete-profile', { profileId, requestedByUserId });
    events.emit(PROFILE_EVENTS.GDPR_DELETION_QUEUED, { eventType: PROFILE_EVENTS.GDPR_DELETION_QUEUED, profileId, userId: requestedByUserId, timestamp: '', correlationId: '', payload: {} });
    return { jobId: job.id };
  }
}


===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/privacy/privacy.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.controller.ts =====
import { Request, Response } from 'express';
import { ResumeSyncService } from './resume-sync.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new ResumeSyncService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.repository.ts =====
import { prisma } from '../../../../config/database';
export class ResumeSyncRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './resume-sync.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const resumeSyncRouter = Router();
resumeSyncRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.service.ts =====
import { prisma } from '../../../../config/database';
import { UnauthorizedError } from '../../../../shared/errors/UnauthorizedError';
import { ForbiddenError } from '../../../../shared/errors/ForbiddenError';
import { events } from '../../../../shared/utils/events';
import { PROFILE_EVENTS } from '../../candidate-profile.events';
import crypto from 'crypto';
import { env } from '../../../../config/env';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const s3 = new S3Client({ region: env.AWS_REGION, credentials: { accessKeyId: env.AWS_ACCESS_KEY_ID, secretAccessKey: env.AWS_SECRET_ACCESS_KEY } });

export class ResumeSyncService {
  async dummyLogic() { return true; }

  async initiateResumeUpload(profileId: string, dto: any) {
    const key = 'resumes/' + profileId + '/' + Date.now() + '-' + dto.fileName;
    const command = new PutObjectCommand({ Bucket: env.AWS_S3_BUCKET_NAME, Key: key, ContentType: dto.fileMimeType });
    const uploadUrl = await getSignedUrl(s3, command, { expiresIn: 900 });

    await prisma.resumeVersion.updateMany({ where: { profileId }, data: { isActive: false } });
    const last = await prisma.resumeVersion.findFirst({ where: { profileId }, orderBy: { versionNumber: 'desc' } });
    const nextV = (last?.versionNumber || 0) + 1;

    const rv = await prisma.resumeVersion.create({
      data: {
        profileId, versionNumber: nextV, fileName: dto.fileName, fileMimeType: dto.fileMimeType,
        fileSizeBytes: dto.fileSizeBytes, storageKey: key, parseStatus: 'PENDING'
      }
    });
    return { uploadUrl, resumeVersionId: rv.id, storageKey: key, expiresAt: new Date(Date.now() + 900000) };
  }

  async handleParseWebhook(payload: any, hmacSignature: string, rawBody: string) {
    const expectedSig = crypto.createHmac("sha256", env.RESUME_PARSE_WEBHOOK_SECRET).update(rawBody).digest("hex");
    const providedSig = Buffer.from(hmacSignature, "hex");
    const expectedBuf = Buffer.from(expectedSig, "hex");
    if (providedSig.length !== expectedBuf.length || !crypto.timingSafeEqual(providedSig, expectedBuf)) {
      throw new UnauthorizedError("Invalid webhook signature");
    }
    const rv = await prisma.resumeVersion.findFirst({ where: { parseJobId: payload.parseJobId } });
    if (!rv) return;
    if (rv.parseStatus === 'COMPLETED' || rv.parseStatus === 'USER_CONFIRMED') return;

    await prisma.resumeVersion.update({ where: { id: rv.id }, data: { parseStatus: 'COMPLETED', parsedData: payload.parsedData } });
    events.emit(PROFILE_EVENTS.RESUME_PARSED, { eventType: PROFILE_EVENTS.RESUME_PARSED, profileId: rv.profileId, userId: '', timestamp: '', correlationId: '', payload });
  }

  async confirmParsedResume(profileId: string, resumeVersionId: string, dto: any, requestingUser: any) {
    const rv = await prisma.resumeVersion.findFirst({ where: { id: resumeVersionId } });
    if (rv?.profileId !== profileId) throw new ForbiddenError();
    if (rv?.parseStatus !== 'COMPLETED') throw new Error('Wait for completion');

    await prisma.$transaction(async (tx) => {
      await tx.resumeVersion.update({ where: { id: resumeVersionId }, data: { userConfirmed: true, userConfirmedAt: new Date(), parseStatus: 'USER_CONFIRMED' } });
    });
    events.emit(PROFILE_EVENTS.RESUME_CONFIRMED, { eventType: PROFILE_EVENTS.RESUME_CONFIRMED, profileId, userId: requestingUser.userId, timestamp: '', correlationId: '', payload: dto });
  }
}


===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/resume-sync/resume-sync.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.controller.ts =====
import { Request, Response } from 'express';
import { SkillsService } from './skills.service';
import { sendResponse } from '../../../../shared/utils/apiResponse';
const service = new SkillsService();
export const dummyHandler = async (req: Request, res: Response) => {
  const data = await service.dummyLogic();
  sendResponse(res, 200, data);
};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.repository.ts =====
import { prisma } from '../../../../config/database';
export class SkillsRepository {
  async dummyOp(tx?: any) {
    const db = tx || prisma;
    return true;
  }
}

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.routes.ts =====
import { Router } from 'express';
import { validateMiddleware } from '../../../../middleware/validate.middleware';
import { dummyHandler } from './skills.controller';
import { asyncHandler } from '../../../../shared/utils/asyncHandler';
export const skillsRouter = Router();
skillsRouter.get('/', asyncHandler(dummyHandler));

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.service.ts =====
import { prisma } from '../../../../config/database';
import { NotFoundError } from '../../../../shared/errors/NotFoundError';
import { ConflictError } from '../../../../shared/errors/ConflictError';
import { ForbiddenError } from '../../../../shared/errors/ForbiddenError';
import { events } from '../../../../shared/utils/events';
import { PROFILE_EVENTS } from '../../candidate-profile.events';

export class SkillsService {
  async dummyLogic() { return true; }
  async addSkillToProfile(profileId: string, dto: any, requestingUser: any) {
    const { skillId, proficiency, yearsOfExp } = dto;
    const skill = await prisma.skill.findUnique({ where: { id: skillId } });
    if (!skill) throw new NotFoundError('Skill not found in catalog');
    const profile = await prisma.candidateProfile.findUnique({ where: { id: profileId } });
    if (profile?.userId !== requestingUser.userId && requestingUser.role !== 'ADMIN') throw new ForbiddenError('Permission denied');
    const duplicate = await prisma.candidateSkill.findUnique({ where: { profileId_skillId: { profileId, skillId } } });
    if (duplicate) throw new ConflictError('Skill already exists on profile');
    const cs = await prisma.candidateSkill.create({ data: { profileId, skillId, proficiency, yearsOfExp } });
    events.emit(PROFILE_EVENTS.SKILLS_UPDATED, { eventType: PROFILE_EVENTS.SKILLS_UPDATED, profileId, userId: profile!.userId, timestamp: new Date().toISOString(), correlationId: '', payload: dto });
    return cs;
  }
  async updateSkill(id: string, profileId: string, dto: any, requestingUser: any) {
    const cs = await prisma.candidateSkill.findFirst({ where: { id, profileId } });
    if (!cs) throw new ForbiddenError('Not your skill or does not exist');
    return prisma.candidateSkill.update({ where: { id }, data: dto });
  }
  async removeSkill(id: string, profileId: string, requestingUser: any) {
    const cs = await prisma.candidateSkill.findFirst({ where: { id, profileId } });
    if (!cs) throw new ForbiddenError('Not your skill');
    await prisma.candidateSkill.delete({ where: { id } });
  }
  async bulkUpsertSkills(profileId: string, skills: any[]) {
    return prisma.$transaction(async (tx) => {
      let count = 0;
      for (const s of skills) {
        await tx.candidateSkill.upsert({
          where: { profileId_skillId: { profileId, skillId: s.skillId } },
          update: { proficiency: s.proficiency },
          create: { profileId, skillId: s.skillId, proficiency: s.proficiency }
        });
        count++;
      }
      return count;
    });
  }
  async searchSkills(query: string, categoryId?: string, limit: number = 20) {
    return prisma.$queryRawUnsafe('SELECT * FROM skills WHERE similarity(name, $1) > 0.3 ORDER BY similarity DESC LIMIT $2', query, limit);
  }
}


===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/modules/candidate-profile/sub-modules/skills/skills.validator.ts =====
import { z } from 'zod';
export const DummyDto = z.object({});

===== FILE: ./smarthire-backend/src/shared/errors/AppError.ts =====
export class AppError extends Error {
  constructor(message: string, public code: string = 'INTERNAL_ERROR', public statusCode: number = 500, public details?: any) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

===== FILE: ./smarthire-backend/src/shared/errors/ConflictError.ts =====
import { AppError } from './AppError';
export class ConflictError extends AppError { constructor(msg='Conflict') { super(msg, 'CONFLICT', 409); } }

===== FILE: ./smarthire-backend/src/shared/errors/ForbiddenError.ts =====
import { AppError } from './AppError';
export class ForbiddenError extends AppError { constructor(msg='Forbidden') { super(msg, 'FORBIDDEN', 403); } }

===== FILE: ./smarthire-backend/src/shared/errors/NotFoundError.ts =====
import { AppError } from './AppError';
export class NotFoundError extends AppError { constructor(msg='Not found') { super(msg, 'NOT_FOUND', 404); } }

===== FILE: ./smarthire-backend/src/shared/errors/RateLimitError.ts =====
import { AppError } from './AppError';
export class RateLimitError extends AppError { constructor(msg='Rate limit exceeded') { super(msg, 'RATE_LIMIT_EXCEEDED', 429); } }

===== FILE: ./smarthire-backend/src/shared/errors/UnauthorizedError.ts =====
import { AppError } from './AppError';
export class UnauthorizedError extends AppError { constructor(msg='Unauthorized') { super(msg, 'UNAUTHORIZED', 401); } }

===== FILE: ./smarthire-backend/src/shared/errors/ValidationError.ts =====
import { AppError } from './AppError';
export class ValidationError extends AppError { constructor(details:any, msg='Validation error') { super(msg, 'VALIDATION_ERROR', 400, details); } }

===== FILE: ./smarthire-backend/src/shared/types/common.types.ts =====
export {};

===== FILE: ./smarthire-backend/src/shared/types/express.d.ts =====
declare namespace Express { interface Request { id?: string; user?: { userId: string; role: string; email: string; } } }

===== FILE: ./smarthire-backend/src/shared/utils/apiResponse.ts =====
import { Response } from 'express';
export const sendResponse = (res: Response, statusCode: number, data: any) => res.status(statusCode).json({ success: statusCode >= 200 && statusCode < 300, data });
export const sendPaginatedResponse = (res: Response, items: any[], meta: any) => res.json({ success: true, data: { items, meta } });

===== FILE: ./smarthire-backend/src/shared/utils/asyncHandler.ts =====
import { Request, Response, NextFunction } from 'express';
export const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) => { Promise.resolve(fn(req, res, next)).catch(next); };

===== FILE: ./smarthire-backend/src/shared/utils/events.ts =====
import { EventEmitter } from 'events';
class TypedEventEmitter extends EventEmitter {}
export const events = new TypedEventEmitter();

===== FILE: ./smarthire-backend/src/shared/utils/logger.ts =====
import winston from 'winston';
import { env } from '../../config/env';
export const logger = winston.createLogger({ level: env.LOG_LEVEL, format: winston.format.json(), transports: [new winston.transports.Console()] });

===== FILE: ./smarthire-backend/src/shared/utils/pagination.ts =====
export interface CursorPagination { cursor?: string; limit: number; }
export interface PaginatedResult<T> { items: T[]; meta: { limit: number; hasNextPage: boolean; nextCursor: string | null; }; }

===== FILE: ./smarthire-backend/tests/integration/candidate-profile.integration.test.ts =====
describe('Integration CandidateProfile', () => {
  it('should return 401 without auth token (POST /profile)', () => {
    expect(true).toBe(true);
  });
});

===== FILE: ./smarthire-backend/tests/unit/candidate-profile.service.test.ts =====
import { CandidateProfileService } from '../../src/modules/candidate-profile/candidate-profile.service';
jest.mock('../../src/modules/candidate-profile/candidate-profile.repository');
jest.mock('../../src/config/database', () => ({ prisma: { $transaction: jest.fn(), candidateProfile: { updateMany: jest.fn() } } }));

describe('CandidateProfileService', () => {
  let service: CandidateProfileService;
  beforeEach(() => { service = new CandidateProfileService(); });

  describe('computeCompleteness', () => {
    it('should return 0 for empty profile', () => {
      expect(service.computeCompleteness({}).score).toBe(0);
    });
    it('should return partial score when basic fields filled', () => {
      expect(service.computeCompleteness({ fullName: 'A', phoneCountryCode: '1', headline: 'B', bio: 'C', locationCity: 'D' }).score).toBe(25);
    });
  });
});

===== FILE: ./smarthire-backend/tests/unit/resume-intelligence.service.test.ts =====
describe('ResumeIntelligenceService', () => {
  it('should throw UnauthorizedError on invalid HMAC', () => {
    expect(true).toBe(true);
  });
});

===== FILE: ./smarthire-backend/tests/unit/skills.service.test.ts =====
describe('SkillsService', () => {
  it('should be idempotent on bulkUpsertSkills', () => {
    expect(true).toBe(true);
  });
});

===== FILE: ./smarthire-backend/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": [
      "ES2022"
    ],
    "outDir": "dist",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "baseUrl": ".",
    "paths": {
      "@/": [
        "src/"
      ]
    }
  },
  "include": [
    "src",
    "server.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "tests"
  ]
}

===== FILE: ./src/app.ts =====
import 'dotenv/config';
import { env } from './config/env';
import { buildServer } from './infrastructure/http/server';
import { prisma } from './infrastructure/db/prisma.client';
import { redis } from './infrastructure/redis/redis.client';
import { authRoutes } from './modules/auth/auth.routes';
import { candidateRoutes } from './modules/candidate/candidate.routes';
import { resumeRoutes } from './modules/resume/resume.routes';
import { jobsRoutes } from './modules/jobs/jobs.routes';
import { applicationRoutes } from './modules/applications/application.routes';
import { skillsRoutes } from './modules/skills/skills.routes';
import { careerRoutes } from './modules/career/career.routes';
import scoringRoutes from '@/modules/scoring/scoring.routes';

async function start() {
  const fastify = await buildServer() as any;

  fastify.register(authRoutes, { prefix: '/api/v1/auth' });
  fastify.register(candidateRoutes, { prefix: '/api/v1/candidates' });
  fastify.register(resumeRoutes, { prefix: '/api/v1/resumes' });
  fastify.register(jobsRoutes, { prefix: '/api/v1/jobs' });
  fastify.register(applicationRoutes, { prefix: '/api/v1/applications' });
  fastify.register(skillsRoutes, { prefix: '/api/v1/skills' });
  fastify.register(careerRoutes, { prefix: '/api/v1/career' });
  fastify.register(scoringRoutes, { prefix: '/api/v1/scoring' });

  try {
    await prisma.$connect();
    fastify.log.info('Database connected');

    await redis.ping();
    fastify.log.info('Redis connected');

    await fastify.listen({ port: env.PORT, host: '0.0.0.0' });
    fastify.log.info(`Server running on port ${env.PORT}`);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }

  const shutdown = async (signal: string) => {
    fastify.log.info(`Received ${signal}, starting graceful shutdown...`);
    await fastify.close();
    await prisma.$disconnect();
    await redis.quit();
    fastify.log.info('Graceful shutdown complete');
    process.exit(0);
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}

start();


===== FILE: ./src/config/constants.ts =====
export const MAX_RESUME_FILE_SIZE_BYTES = 5 * 1024 * 1024; // 5MB
export const MAX_RESUME_FILES_PER_REQUEST = 1;
export const PARSE_CACHE_TTL_SECONDS = 60 * 60 * 24 * 7; // 7 days
export const ALLOWED_RESUME_MIMES = [
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
] as const;
export const ALLOWED_RESUME_EXTENSIONS = ['.pdf', '.docx'] as const;


===== FILE: ./src/config/env.ts =====
import { z } from 'zod';

const EnvSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().min(1, 'DATABASE_URL is required'),
  REDIS_URL: z.string().min(1, 'REDIS_URL is required'),
  JWT_SECRET: z.string().min(32, 'JWT_SECRET must be at least 32 characters'),
  JWT_EXPIRES_IN: z.string().default('15m'),
  REFRESH_TOKEN_EXPIRES_IN: z.string().default('30d'),
  OPENAI_API_KEY: z.string().startsWith('sk-', 'Invalid OpenAI API key format'),
  OPENAI_PARSE_MODEL: z.string().default('gpt-4o-mini'),
  OPENAI_SUGGEST_MODEL: z.string().default('gpt-4o'),
  AWS_ACCESS_KEY_ID: z.string().min(1),
  AWS_SECRET_ACCESS_KEY: z.string().min(1),
  AWS_REGION: z.string().default('ap-south-1'),
  S3_BUCKET: z.string().min(1),
  FRONTEND_URL: z.string().url().default('http://localhost:5173'),
  CORS_ORIGINS: z.string().optional(),
  RESEND_API_KEY: z.string().optional(),
  SENTRY_DSN: z.string().url().optional(),
});

export type Env = z.infer<typeof EnvSchema>;

const parsed = EnvSchema.safeParse(process.env);
if (!parsed.success) {
  console.error('âŒ Invalid environment variables:');
  console.error(parsed.error.flatten().fieldErrors);
  process.exit(1);
}

export const env = parsed.data;

export function getCorsOrigins(): string[] {
  if (env.CORS_ORIGINS) {
    return env.CORS_ORIGINS.split(',').map((url) => url.trim()).filter(Boolean);
  }
  return [env.FRONTEND_URL];
}


===== FILE: ./src/infrastructure/ai/openai.client.ts =====
import OpenAI from 'openai';
import { env } from '../../config/env';

export const openai = new OpenAI({
  apiKey: env.OPENAI_API_KEY,
});

export const PARSE_MODEL = env.OPENAI_PARSE_MODEL;
export const SUGGEST_MODEL = env.OPENAI_SUGGEST_MODEL;


===== FILE: ./src/infrastructure/db/prisma.client.ts =====
import { PrismaClient } from '@prisma/client';
import { env } from '../../config/env';

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      env.NODE_ENV === 'development'
        ? ['query', 'error', 'warn']
        : ['error'],
  });

if (env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}


===== FILE: ./src/infrastructure/http/middleware/error.handler.ts =====
import type { FastifyRequest, FastifyReply } from 'fastify';
import { ZodError } from 'zod';
import { env } from '../../../config/env';
import { AppError, ValidationError as AppValidationError } from '../../../shared/errors';

export function errorHandler(
  error: Error & { statusCode?: number; validation?: unknown },
  request: FastifyRequest,
  reply: FastifyReply
) {
  const log = (request as any).log;

  if (error instanceof AppError) {
    log.warn({ err: error, statusCode: error.statusCode }, error.message);
    return (reply as any).status(error.statusCode ?? 500).send({
      status: 'error',
      message: error.message,
      ...(error instanceof AppValidationError && error.errors && { errors: error.errors }),
    });
  }

  if (error.validation) {
    return (reply as any).status(400).send({
      status: 'error',
      message: 'Validation failed',
      errors: error.validation,
    });
  }

  if (error instanceof ZodError) {
    return (reply as any).status(400).send({
      status: 'error',
      message: 'Validation failed',
      errors: error.flatten().fieldErrors,
    });
  }

  if (log) log.error({ err: error }, 'Unexpected error');

  const message =
    env.NODE_ENV === 'production' ? 'Internal server error' : (error.message ?? 'Unknown error');

  return (reply as any).status(error.statusCode ?? 500).send({
    status: 'error',
    message,
  });
}

export function isAppError(err: unknown): err is AppError {
  return err instanceof AppError;
}


===== FILE: ./src/infrastructure/http/plugins/auth.plugin.ts =====
import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import fp from 'fastify-plugin';
import jwt from 'jsonwebtoken';
import { env } from '../../../config/env';
import { UnauthorizedError } from '../../../shared/errors';

export interface JWTPayload {
  sub: string;
  role: 'candidate' | 'recruiter';
  iat: number;
  exp: number;
}

async function authPlugin(fastify: FastifyInstance) {
  (fastify as any).decorate('authenticate', async function (request: any, _reply: any) {
    const authHeader = request.headers?.authorization;
    const token = authHeader?.startsWith('Bearer ') ? authHeader.slice(7) : null;

    if (!token) {
      throw new UnauthorizedError('No token provided');
    }

    try {
      const payload = jwt.verify(token, env.JWT_SECRET) as JWTPayload;
      request.user = payload;
    } catch {
      throw new UnauthorizedError('Invalid token');
    }
  });
}

export default fp(authPlugin, { name: 'auth-plugin' });

declare module 'fastify' {
  interface FastifyInstance {
    authenticate: (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
  }
}


===== FILE: ./src/infrastructure/http/server.ts =====
// eslint-disable-next-line @typescript-eslint/no-var-requires
const Fastify = require('fastify');
import helmet from '@fastify/helmet';
import cors from '@fastify/cors';
import rateLimit from '@fastify/rate-limit';
import multipart from '@fastify/multipart';
import { randomUUID } from 'crypto';
import { env, getCorsOrigins } from '../../config/env';
import { errorHandler } from './middleware/error.handler';
import authPlugin from './plugins/auth.plugin';
import { prisma } from '../db/prisma.client';
import { redis } from '../redis/redis.client';
import { resumeParsingQueue } from '../queue/queues/resume.queue';
import { MAX_RESUME_FILE_SIZE_BYTES } from '../../config/constants';
import type { FastifyInstance } from 'fastify';

export async function buildServer(): Promise<FastifyInstance> {
  const fastify = Fastify({
    logger: {
      level: env.NODE_ENV === 'production' ? 'info' : 'debug',
    },
    genReqId: (req: any) => {
      return (req.headers['x-request-id'] as string) ?? randomUUID();
    },
  });

  await fastify.register(helmet, { contentSecurityPolicy: false });
  await fastify.register(cors, {
    origin: getCorsOrigins(),
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    credentials: true,
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],
  });
  await fastify.register(rateLimit, {
    max: 100,
    timeWindow: '1 minute',
    keyGenerator: (req: any) => req.user?.sub ?? req.ip ?? 'anonymous',
  });
  await fastify.register(multipart, {
    limits: {
      fileSize: MAX_RESUME_FILE_SIZE_BYTES,
      files: 1,
      fieldNameSize: 100,
      fieldSize: 1000,
    },
  });
  await fastify.register(authPlugin);

  fastify.setErrorHandler(errorHandler);

  fastify.get('/health', async (_request: any, reply: any) => {
    const checks = await Promise.allSettled([
      prisma.$queryRaw`SELECT 1`,
      redis.ping(),
      resumeParsingQueue.getJobCounts(),
    ]);

    const [db, redisCheck, queueCheck] = checks;

    return reply.send({
      status: checks.every((c) => c.status === 'fulfilled') ? 'ok' : 'degraded',
      timestamp: new Date().toISOString(),
      services: {
        database: db.status === 'fulfilled' ? 'ok' : 'error',
        redis: redisCheck.status === 'fulfilled' ? 'ok' : 'error',
        queue: queueCheck.status === 'fulfilled' ? 'ok' : 'error',
        queueCounts:
          queueCheck.status === 'fulfilled' && 'value' in queueCheck
            ? queueCheck.value
            : null,
      },
    });
  });

  return fastify;
}


===== FILE: ./src/infrastructure/queue/queue.client.ts =====
import type { Redis } from 'ioredis';
import { redis } from '../redis/redis.client';

export function getQueueConnection(): Redis {
  return redis;
}


===== FILE: ./src/infrastructure/queue/queues/resume.queue.ts =====
import { Queue } from 'bullmq';
import { redis } from '../../redis/redis.client';

export const resumeParsingQueue = new Queue('resume-parsing', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 2000 },
    removeOnComplete: 100,
    removeOnFail: 500,
  },
});


===== FILE: ./src/infrastructure/queue/workers/resume-parser.worker.ts =====
import { Worker } from 'bullmq';
import { redis } from '../../redis/redis.client';
import { runParserPipeline } from '../../../modules/parser/parser.pipeline';

export const resumeParserWorker = new Worker(
  'resume-parsing',
  async (job) => {
    const { resumeId } = job.data as { resumeId: string };
    await runParserPipeline(resumeId);
  },
  {
    connection: redis,
    concurrency: 3,
    limiter: {
      max: 60,
      duration: 60_000,
    },
  }
);

resumeParserWorker.on('completed', (job) => {
  console.log(`Resume parsed: ${job?.data?.resumeId}`);
});

resumeParserWorker.on('failed', (job, err) => {
  console.error(`Resume parse failed: ${job?.data?.resumeId}`, err);
});


===== FILE: ./src/infrastructure/redis/redis.client.ts =====
import Redis from 'ioredis';
import { env } from '../../config/env';

export const redis = new Redis(env.REDIS_URL, {
  maxRetriesPerRequest: null,
  retryStrategy(times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});


===== FILE: ./src/infrastructure/storage/s3.client.ts =====
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { createWriteStream } from 'fs';
import { unlink } from 'fs/promises';
import { tmpdir } from 'os';
import { join } from 'path';
import { randomUUID } from 'crypto';
import { pipeline } from 'stream/promises';
import { Readable } from 'stream';
import { env } from '../../config/env';
import { MAX_RESUME_FILE_SIZE_BYTES } from '../../config/constants';

const s3 = new S3Client({
  region: env.AWS_REGION,
  credentials: {
    accessKeyId: env.AWS_ACCESS_KEY_ID,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY,
  },
});

export async function uploadResume(
  file: Buffer,
  candidateId: string,
  fileName: string,
  contentType: string
): Promise<string> {
  const key = `resumes/${candidateId}/${Date.now()}-${fileName}`;

  await s3.send(
    new PutObjectCommand({
      Bucket: env.S3_BUCKET,
      Key: key,
      Body: file,
      ContentType: contentType,
      ServerSideEncryption: 'AES256',
    })
  );

  return key;
}

export async function getResumeViewUrl(key: string): Promise<string> {
  return getSignedUrl(
    s3,
    new GetObjectCommand({
      Bucket: env.S3_BUCKET,
      Key: key,
    }),
    { expiresIn: 3600 }
  );
}

export async function downloadFromS3(key: string): Promise<string> {
  const tempPath = join(tmpdir(), `smarthire-resume-${randomUUID()}`);

  const command = new GetObjectCommand({
    Bucket: env.S3_BUCKET,
    Key: key,
  });
  const response = await s3.send(command);
  const body = response.Body as Readable;

  if (!body) {
    throw new Error('Empty S3 response body');
  }

  const writeStream = createWriteStream(tempPath);
  await pipeline(body, writeStream);

  return tempPath;
}

export async function deleteLocalFile(path: string): Promise<void> {
  try {
    await unlink(path);
  } catch {
    // File already deleted or never created
  }
}



===== FILE: ./src/modules/applications/application.controller.ts =====
import * as applicationService from './application.service';
import { applyBodySchema } from './application.schema';
import { jobIdParamSchema } from '../jobs/jobs.schema';
import { success } from '../../shared/utils/response';
import { UnauthorizedError } from '../../shared/errors';

function getCandidateId(request: any): string {
  const sub = request.user?.sub;
  if (!sub) throw new UnauthorizedError('Not authenticated');
  return sub;
}

export async function applyHandler(request: any, reply: any) {
  const { id: jobId } = jobIdParamSchema.parse(request.params);
  const body = applyBodySchema.parse(request.body);
  const candidateId = getCandidateId(request);
  const data = await applicationService.apply(candidateId, jobId, body.resumeId);
  return success(reply, data, 201);
}

export async function listHandler(request: any, reply: any) {
  const candidateId = getCandidateId(request);
  const data = await applicationService.listByCandidate(candidateId);
  return success(reply, data);
}


===== FILE: ./src/modules/applications/application.routes.ts =====
import type { FastifyInstance } from 'fastify';
import { listHandler } from './application.controller';

export async function applicationRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.addHook('preHandler', f.authenticate);
  f.get('/', listHandler);
}


===== FILE: ./src/modules/applications/application.schema.ts =====
import { z } from 'zod';

export const applyBodySchema = z.object({
  resumeId: z.string().min(1),
});

export type ApplyBody = z.infer<typeof applyBodySchema>;


===== FILE: ./src/modules/applications/application.service.ts =====
import { ConflictError, NotFoundError, ForbiddenError } from '../../shared/errors';
import { prisma } from '../../infrastructure/db/prisma.client';

export async function apply(candidateId: string, jobId: string, resumeId: string) {
  const [job, resume] = await Promise.all([
    prisma.job.findUnique({ where: { id: jobId, status: 'ACTIVE' } }),
    prisma.resume.findFirst({ where: { id: resumeId, candidateId } }),
  ]);

  if (!job) throw new NotFoundError('Job not found');
  if (!resume) throw new NotFoundError('Resume not found');

  const existing = await prisma.application.findUnique({
    where: {
      candidateId_jobId: { candidateId, jobId },
    },
  });
  if (existing) throw new ConflictError('Already applied to this job');

  return prisma.application.create({
    data: {
      candidateId,
      jobId,
      resumeId,
    },
  });
}

export async function listByCandidate(candidateId: string) {
  return prisma.application.findMany({
    where: { candidateId },
    include: {
      job: {
        select: {
          id: true,
          title: true,
          company: true,
          location: true,
          status: true,
        },
      },
    },
    orderBy: { appliedAt: 'desc' },
  });
}


===== FILE: ./src/modules/auth/auth.controller.ts =====
import * as authService from './auth.service';
import { signupSchema, loginSchema, refreshSchema } from './auth.schema';
import { success } from '../../shared/utils/response';

export async function signupHandler(request: any, reply: any) {
  const body = signupSchema.parse(request.body);
  const result = await authService.signup(body);
  return success(reply, result, 201);
}

export async function loginHandler(request: any, reply: any) {
  const body = loginSchema.parse(request.body);
  const result = await authService.login(body);
  return success(reply, result);
}

export async function refreshHandler(request: any, reply: any) {
  const body = refreshSchema.parse(request.body);
  const result = await authService.refreshTokens(body);
  return success(reply, result);
}

export async function logoutHandler(request: any, reply: any) {
  const body = refreshSchema.safeParse(request.body);
  if (body.success && body.data.refreshToken) {
    await authService.logout(body.data.refreshToken);
  }
  return success(reply, { message: 'Logged out' });
}


===== FILE: ./src/modules/auth/auth.routes.ts =====
import type { FastifyInstance } from 'fastify';
import { signupHandler, loginHandler, refreshHandler, logoutHandler } from './auth.controller';

export async function authRoutes(fastify: FastifyInstance) {
  (fastify as any).post('/signup', signupHandler);
  (fastify as any).post('/login', loginHandler);
  (fastify as any).post('/refresh', refreshHandler);
  (fastify as any).post('/logout', logoutHandler);
}


===== FILE: ./src/modules/auth/auth.schema.ts =====
import { z } from 'zod';

export const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  fullName: z.string().min(1).optional(),
});

export const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export const refreshSchema = z.object({
  refreshToken: z.string().min(1),
});

export type SignupInput = z.infer<typeof signupSchema>;
export type LoginInput = z.infer<typeof loginSchema>;
export type RefreshInput = z.infer<typeof refreshSchema>;


===== FILE: ./src/modules/auth/auth.service.ts =====
import { createHash } from 'crypto';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { prisma } from '../../infrastructure/db/prisma.client';
import { env } from '../../config/env';
import { UnauthorizedError, ConflictError } from '../../shared/errors';
import type { JWTPayload, AuthTokens } from './auth.types';
import type { SignupInput, LoginInput, RefreshInput } from './auth.schema';

const SALT_ROUNDS = 10;

function hashToken(token: string): string {
  return createHash('sha256').update(token).digest('hex');
}

function issueAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  return jwt.sign(payload, env.JWT_SECRET, {
    expiresIn: env.JWT_EXPIRES_IN,
  } as jwt.SignOptions);
}

function issueRefreshToken(candidateId: string): string {
  return jwt.sign(
    { sub: candidateId, type: 'refresh' },
    env.JWT_SECRET,
    { expiresIn: env.REFRESH_TOKEN_EXPIRES_IN } as jwt.SignOptions
  );
}

function parseExpiry(expiresIn: string): number {
  const match = expiresIn.match(/^(\d+)([smhd])$/);
  if (!match) return 900;
  const [, num, unit] = match;
  const n = parseInt(num!, 10);
  const multipliers: Record<string, number> = { s: 1, m: 60, h: 3600, d: 86400 };
  return n * (multipliers[unit!] ?? 60);
}

export async function signup(input: SignupInput): Promise<AuthTokens & { candidateId: string }> {
  const existing = await prisma.candidate.findUnique({
    where: { email: input.email.toLowerCase() },
  });
  if (existing) {
    throw new ConflictError('Email already registered');
  }

  const passwordHash = await bcrypt.hash(input.password, SALT_ROUNDS);
  const candidate = await prisma.candidate.create({
    data: {
      email: input.email.toLowerCase(),
      passwordHash,
    },
  });

  const refreshToken = issueRefreshToken(candidate.id);
  const tokenHash = hashToken(refreshToken);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 30);

  await prisma.refreshToken.create({
    data: {
      candidateId: candidate.id,
      tokenHash,
      expiresAt,
    },
  });

  const accessToken = issueAccessToken({
    sub: candidate.id,
    role: 'candidate',
  });

  return {
    accessToken,
    refreshToken,
    expiresIn: parseExpiry(env.JWT_EXPIRES_IN),
    candidateId: candidate.id,
  };
}

export async function login(input: LoginInput): Promise<AuthTokens & { candidateId: string }> {
  const candidate = await prisma.candidate.findUnique({
    where: { email: input.email.toLowerCase() },
  });
  if (!candidate || !candidate.passwordHash) {
    throw new UnauthorizedError('Invalid credentials');
  }

  const valid = await bcrypt.compare(input.password, candidate.passwordHash);
  if (!valid) {
    throw new UnauthorizedError('Invalid credentials');
  }

  const refreshToken = issueRefreshToken(candidate.id);
  const tokenHash = hashToken(refreshToken);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 30);

  await prisma.refreshToken.create({
    data: {
      candidateId: candidate.id,
      tokenHash,
      expiresAt,
    },
  });

  const accessToken = issueAccessToken({
    sub: candidate.id,
    role: 'candidate',
  });

  return {
    accessToken,
    refreshToken,
    expiresIn: parseExpiry(env.JWT_EXPIRES_IN),
    candidateId: candidate.id,
  };
}

export async function refreshTokens(input: RefreshInput): Promise<AuthTokens> {
  const hash = hashToken(input.refreshToken);

  const storedToken = await prisma.refreshToken.findFirst({
    where: { tokenHash: hash, isRevoked: false },
    include: { candidate: true },
  });

  if (!storedToken || storedToken.expiresAt < new Date()) {
    if (storedToken) {
      await prisma.refreshToken.updateMany({
        where: { candidateId: storedToken.candidateId },
        data: { isRevoked: true },
      });
    }
    throw new UnauthorizedError('Invalid or expired refresh token');
  }

  await prisma.refreshToken.update({
    where: { id: storedToken.id },
    data: { isRevoked: true },
  });

  const newRefreshToken = issueRefreshToken(storedToken.candidateId);
  const newTokenHash = hashToken(newRefreshToken);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 30);

  await prisma.refreshToken.create({
    data: {
      candidateId: storedToken.candidateId,
      tokenHash: newTokenHash,
      expiresAt,
    },
  });

  const accessToken = issueAccessToken({
    sub: storedToken.candidateId,
    role: 'candidate',
  });

  return {
    accessToken,
    refreshToken: newRefreshToken,
    expiresIn: parseExpiry(env.JWT_EXPIRES_IN),
  };
}

export async function logout(refreshToken: string): Promise<void> {
  const hash = hashToken(refreshToken);
  await prisma.refreshToken.updateMany({
    where: { tokenHash: hash },
    data: { isRevoked: true },
  });
}


===== FILE: ./src/modules/auth/auth.types.ts =====
export interface JWTPayload {
  sub: string;
  role: 'candidate' | 'recruiter';
  iat: number;
  exp: number;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface LoginBody {
  email: string;
  password: string;
}

export interface SignupBody {
  email: string;
  password: string;
  fullName?: string;
}

export interface RefreshBody {
  refreshToken: string;
}


===== FILE: ./src/modules/candidate/candidate.controller.ts =====
import * as candidateService from './candidate.service';
import { updateProfileSchema } from './candidate.schema';
import { success } from '../../shared/utils/response';
import { UnauthorizedError } from '../../shared/errors';

function getCandidateId(request: any): string {
  const sub = request.user?.sub;
  if (!sub) throw new UnauthorizedError('Not authenticated');
  return sub;
}

export async function getMeHandler(request: any, reply: any) {
  const candidateId = getCandidateId(request);
  const data = await candidateService.getMe(candidateId);
  return success(reply, data);
}

export async function updateMeHandler(request: any, reply: any) {
  const candidateId = getCandidateId(request);
  const body = updateProfileSchema.parse(request.body);
  const data = await candidateService.updateProfile(candidateId, body);
  return success(reply, data);
}

export async function getDashboardHandler(request: any, reply: any) {
  const candidateId = getCandidateId(request);
  const data = await candidateService.getDashboard(candidateId);
  return success(reply, data);
}


===== FILE: ./src/modules/candidate/candidate.repository.ts =====
import { prisma } from '../../infrastructure/db/prisma.client';
import type { UpdateProfileInput } from './candidate.schema';

export async function getCandidateById(id: string) {
  return prisma.candidate.findUnique({
    where: { id },
    include: { profile: true },
  });
}

export async function updateProfile(candidateId: string, data: UpdateProfileInput) {
  return prisma.candidateProfile.upsert({
    where: { candidateId },
    update: data as any,
    create: {
      candidateId,
      fullName: data.fullName ?? 'Unknown',
      ...(data as any),
    },
  });
}

export async function getDashboardData(candidateId: string) {
  const [resumes, applications, profile] = await Promise.all([
    prisma.resume.findMany({
      where: { candidateId, isActive: true },
      orderBy: { version: 'desc' },
      take: 5,
    }),
    prisma.application.findMany({
      where: { candidateId },
      include: { job: { select: { id: true, title: true, company: true, status: true } } },
      orderBy: { appliedAt: 'desc' },
      take: 20,
    }),
    prisma.candidateProfile.findUnique({
      where: { candidateId },
    }),
  ]);

  const activeResume = resumes[0];
  return {
    profile,
    activeResume,
    resumes,
    applications,
    atsScore: activeResume?.atsScore ?? null,
  };
}


===== FILE: ./src/modules/candidate/candidate.routes.ts =====
import type { FastifyInstance } from 'fastify';
import {
  getMeHandler,
  updateMeHandler,
  getDashboardHandler,
} from './candidate.controller';

export async function candidateRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.addHook('preHandler', f.authenticate);
  f.get('/me', getMeHandler);
  f.put('/me', updateMeHandler);
  f.get('/me/dashboard', getDashboardHandler);
}


===== FILE: ./src/modules/candidate/candidate.schema.ts =====
import { z } from 'zod';

export const updateProfileSchema = z.object({
  fullName: z.string().min(1).optional(),
  avatarUrl: z.string().url().optional().nullable(),
  city: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  linkedinUrl: z.string().url().optional().nullable(),
  githubUrl: z.string().url().optional().nullable(),
  portfolioUrl: z.string().url().optional().nullable(),
  preferredRoles: z.array(z.string()).optional(),
  preferredLocations: z.array(z.string()).optional(),
  salaryExpectation: z.number().int().min(0).optional().nullable(),
  workType: z.enum(['remote', 'hybrid', 'onsite']).optional().nullable(),
  experienceLevel: z.enum(['fresher', 'junior', 'mid', 'senior']).optional().nullable(),
  education: z.any().optional(),
  isPublic: z.boolean().optional(),
  showReputationScore: z.boolean().optional(),
});

export type UpdateProfileInput = z.infer<typeof updateProfileSchema>;


===== FILE: ./src/modules/candidate/candidate.service.ts =====
import { NotFoundError } from '../../shared/errors';
import * as candidateRepo from './candidate.repository';
import type { UpdateProfileInput } from './candidate.schema';

export async function getMe(candidateId: string) {
  const candidate = await candidateRepo.getCandidateById(candidateId);
  if (!candidate) {
    throw new NotFoundError('Candidate not found');
  }
  const { passwordHash, ...rest } = candidate;
  return rest;
}

export async function updateProfile(candidateId: string, data: UpdateProfileInput) {
  await candidateRepo.getCandidateById(candidateId);
  return candidateRepo.updateProfile(candidateId, data);
}

export async function getDashboard(candidateId: string) {
  await candidateRepo.getCandidateById(candidateId);
  return candidateRepo.getDashboardData(candidateId);
}


===== FILE: ./src/modules/career/career.routes.ts =====
import type { FastifyInstance } from 'fastify';
import * as careerService from './career.service';
import { success } from '../../shared/utils/response';

export async function careerRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.addHook('preHandler', f.authenticate);

  f.get('/path', async (request: any, reply: any) => {
    const candidateId = request.user?.sub;
    if (!candidateId) return reply.status(401).send({ error: 'Unauthorized' });
    const targetRole = (request.query as any)?.targetRole;
    const data = await careerService.getCareerPath(candidateId, targetRole);
    return success(reply, data);
  });

  f.get('/learning-path', async (request: any, reply: any) => {
    const candidateId = request.user?.sub;
    if (!candidateId) return reply.status(401).send({ error: 'Unauthorized' });
    const skillGaps = (request.query as any)?.skillGaps;
    const data = await careerService.getLearningPath(
      candidateId,
      Array.isArray(skillGaps) ? skillGaps : undefined
    );
    return success(reply, data);
  });
}


===== FILE: ./src/modules/career/career.service.ts =====
import { NotFoundError } from '../../shared/errors';
import { prisma } from '../../infrastructure/db/prisma.client';

export async function getCareerPath(candidateId: string, targetRole?: string) {
  const candidate = await prisma.candidate.findUnique({
    where: { id: candidateId },
  });
  if (!candidate) throw new NotFoundError('Candidate not found');

  return {
    targetRole: targetRole ?? 'SDE-I',
    milestones: [] as { title: string; description: string; order: number }[],
  };
}

export async function getLearningPath(candidateId: string, skillGaps?: string[]) {
  const candidate = await prisma.candidate.findUnique({
    where: { id: candidateId },
  });
  if (!candidate) throw new NotFoundError('Candidate not found');

  return {
    skillGaps: skillGaps ?? [],
    resources: [] as { skill: string; title: string; url: string; type: string }[],
  };
}


===== FILE: ./src/modules/jobs/jobs.controller.ts =====
import * as jobsService from './jobs.service';
import { searchQuerySchema, jobIdParamSchema } from './jobs.schema';
import { success, paginated } from '../../shared/utils/response';
import { UnauthorizedError } from '../../shared/errors';

function getCandidateId(request: any): string | null {
  return request.user?.sub ?? null;
}

export async function searchHandler(request: any, reply: any) {
  const query = searchQuerySchema.parse(request.query);
  const { jobs, total } = await jobsService.searchJobs(query);
  return paginated(reply, jobs, query.page, query.limit, total);
}

export async function getByIdHandler(request: any, reply: any) {
  const { id } = jobIdParamSchema.parse(request.params);
  const data = await jobsService.getJobById(id);
  return success(reply, data);
}

export async function recommendedHandler(request: any, reply: any) {
  const candidateId = getCandidateId(request);
  if (!candidateId) throw new UnauthorizedError('Not authenticated');
  const limit = 20;
  const data = await jobsService.getRecommendedJobs(candidateId, limit);
  return success(reply, data);
}


===== FILE: ./src/modules/jobs/jobs.repository.ts =====
import { prisma } from '../../infrastructure/db/prisma.client';
import type { SearchQuery } from './jobs.schema';

export async function searchJobs(query: SearchQuery) {
  const { q, role, location, experienceMin, experienceMax, page, limit } = query;
  const skip = (page - 1) * limit;

  const where: any = {
    status: 'ACTIVE',
  };

  if (experienceMin != null) {
    where.experienceMax = { gte: experienceMin };
  }
  if (experienceMax != null) {
    where.experienceMin = { lte: experienceMax };
  }
  if (location) {
    where.location = { contains: location, mode: 'insensitive' };
  }
  if (role) {
    where.title = { contains: role, mode: 'insensitive' };
  }
  if (q) {
    where.OR = [
      { title: { contains: q, mode: 'insensitive' } },
      { company: { contains: q, mode: 'insensitive' } },
      { description: { contains: q, mode: 'insensitive' } },
    ];
  }

  const [jobs, total] = await Promise.all([
    prisma.job.findMany({
      where,
      skip,
      take: limit,
      orderBy: { publishedAt: 'desc' },
      include: { requiredSkills: { include: { skill: true } } },
    }),
    prisma.job.count({ where }),
  ]);

  return { jobs, total };
}

export async function getJobById(id: string) {
  return prisma.job.findUnique({
    where: { id, status: 'ACTIVE' },
    include: { requiredSkills: { include: { skill: true } } },
  });
}

export async function getRecommendedJobs(candidateId: string, limit: number = 10) {
  const candidateSkills = await prisma.candidateSkill.findMany({
    where: { candidateId },
    include: { skill: true },
  });
  const skillIds = candidateSkills.map((cs) => cs.skillId);
  const skillNames = candidateSkills.map((cs) => cs.skill.name.toLowerCase());

  const jobs = await prisma.job.findMany({
    where: {
      status: 'ACTIVE',
      OR: [
        { requiredSkills: { some: { skillId: { in: skillIds } } } },
        {
          keywords: {
            hasSome: skillNames.length > 0 ? skillNames : ['developer'],
          },
        },
      ],
    },
    take: limit,
    orderBy: { publishedAt: 'desc' },
    include: { requiredSkills: { include: { skill: true } } },
  });

  return jobs;
}


===== FILE: ./src/modules/jobs/jobs.routes.ts =====
import type { FastifyInstance } from 'fastify';
import { searchHandler, getByIdHandler, recommendedHandler } from './jobs.controller';
import { applyHandler } from '../applications/application.controller';

export async function jobsRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.get('/search', searchHandler);
  f.get('/recommended', { preHandler: f.authenticate }, recommendedHandler);
  f.get('/:id', getByIdHandler);
  f.post('/:id/apply', { preHandler: f.authenticate }, applyHandler);
}


===== FILE: ./src/modules/jobs/jobs.schema.ts =====
import { z } from 'zod';

export const searchQuerySchema = z.object({
  q: z.string().optional(),
  role: z.string().optional(),
  location: z.string().optional(),
  experienceMin: z.coerce.number().optional(),
  experienceMax: z.coerce.number().optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(50).default(20),
});

export const jobIdParamSchema = z.object({
  id: z.string().min(1),
});

export type SearchQuery = z.infer<typeof searchQuerySchema>;
export type JobIdParam = z.infer<typeof jobIdParamSchema>;


===== FILE: ./src/modules/jobs/jobs.service.ts =====
import { NotFoundError } from '../../shared/errors';
import * as jobsRepo from './jobs.repository';
import type { SearchQuery } from './jobs.schema';

export async function searchJobs(query: SearchQuery) {
  return jobsRepo.searchJobs(query);
}

export async function getJobById(id: string) {
  const job = await jobsRepo.getJobById(id);
  if (!job) throw new NotFoundError('Job not found');
  return job;
}

export async function getRecommendedJobs(candidateId: string, limit?: number) {
  return jobsRepo.getRecommendedJobs(candidateId, limit);
}


===== FILE: ./src/modules/parser/extractor.ts =====
import pdf from 'pdf-parse';
import mammoth from 'mammoth';
import { readFile } from 'fs/promises';

export type ExtractionResult = {
  rawText: string;
  pageCount?: number;
  wordCount: number;
  extractionMethod: 'pdf' | 'docx';
};

export async function extractTextFromFile(
  filePath: string,
  fileType: 'pdf' | 'docx'
): Promise<ExtractionResult> {
  const buffer = await readFile(filePath);

  if (fileType === 'pdf') {
    const data = await pdf(buffer);
    return {
      rawText: data.text,
      pageCount: data.numpages,
      wordCount: data.text.split(/\s+/).filter(Boolean).length,
      extractionMethod: 'pdf',
    };
  }

  if (fileType === 'docx') {
    const result = await mammoth.extractRawText({ buffer });
    const text = result.value;
    return {
      rawText: text,
      wordCount: text.split(/\s+/).filter(Boolean).length,
      extractionMethod: 'docx',
    };
  }

  throw new Error(`Unsupported file type: ${fileType}`);
}


===== FILE: ./src/modules/parser/llm.client.ts =====
import OpenAI from 'openai';
import { openai, PARSE_MODEL } from '../../infrastructure/ai/openai.client';
import { RESUME_PARSE_SYSTEM_PROMPT, buildParsePrompt } from './prompt.builder';

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function parseResumeWithLLM(resumeText: string): Promise<string> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= 3; attempt++) {
    try {
      const response = await openai.chat.completions.create({
        model: PARSE_MODEL,
        response_format: { type: 'json_object' },
        temperature: 0,
        max_tokens: 4000,
        messages: [
          { role: 'system', content: RESUME_PARSE_SYSTEM_PROMPT },
          { role: 'user', content: buildParsePrompt(resumeText) },
        ],
      });

      const content = response.choices[0]?.message?.content;
      if (content) return content;
    } catch (err) {
      lastError = err as Error;

      if (err instanceof OpenAI.RateLimitError) {
        const waitMs = attempt * 5000;
        await sleep(waitMs);
        continue;
      }

      if (err instanceof OpenAI.APIError && err.status && err.status >= 500) {
        await sleep(1000 * attempt);
        continue;
      }

      throw err;
    }
  }

  throw lastError ?? new Error('OpenAI parse failed after 3 attempts');
}


===== FILE: ./src/modules/parser/parser.pipeline.ts =====
import { prisma } from '../../infrastructure/db/prisma.client';
import { redis } from '../../infrastructure/redis/redis.client';
import { downloadFromS3, deleteLocalFile } from '../../infrastructure/storage/s3.client';
import { PARSE_CACHE_TTL_SECONDS } from '../../config/constants';
import { extractTextFromFile } from './extractor';
import { preprocessResumeText, truncateToTokenLimit } from './preprocessor';
import { parseResumeWithLLM } from './llm.client';
import { validateParsedResume } from './response.validator';
import { computeATSScore } from './scorer';
import type { ParsedResume } from './response.validator';

export async function runParserPipeline(resumeId: string): Promise<void> {
  const resume = await prisma.resume.findUniqueOrThrow({
    where: { id: resumeId },
  });

  await prisma.resume.update({
    where: { id: resumeId },
    data: { parseStatus: 'PROCESSING' },
  });

  let tempFilePath: string | null = null;

  try {
    const cacheKey = `parsed:resume:${resumeId}`;
    const cached = await redis.get(cacheKey);

    let parsedData: ParsedResume;

    if (cached) {
      parsedData = JSON.parse(cached) as ParsedResume;
    } else {
      tempFilePath = await downloadFromS3(resume.fileUrl);

      const extracted = await extractTextFromFile(
        tempFilePath,
        resume.fileType as 'pdf' | 'docx'
      );

      const cleanText = preprocessResumeText(extracted.rawText);
      const truncatedText = truncateToTokenLimit(cleanText);

      const rawAIOutput = await parseResumeWithLLM(truncatedText);
      const rawJson = JSON.parse(rawAIOutput);
      parsedData = validateParsedResume(rawJson);

      await redis.setex(cacheKey, PARSE_CACHE_TTL_SECONDS, JSON.stringify(parsedData));
    }

    const atsResult = computeATSScore({ parsedResume: parsedData });

    const allSkills = [
      ...parsedData.skills.languages,
      ...parsedData.skills.frameworks,
      ...parsedData.skills.databases,
      ...parsedData.skills.tools,
      ...parsedData.skills.cloud,
    ];

    await prisma.$transaction(async (tx) => {
      await tx.resume.update({
        where: { id: resumeId },
        data: {
          parseStatus: 'COMPLETED',
          parsedData: parsedData as any,
          extractedSkills: allSkills,
          atsScore: atsResult.total,
          yearsExperience: parsedData.metrics.totalExperienceYears,
          parsedAt: new Date(),
        },
      });

      if (parsedData.personalInfo.name) {
        await tx.candidateProfile.upsert({
          where: { candidateId: resume.candidateId },
          update: { fullName: parsedData.personalInfo.name },
          create: {
            candidateId: resume.candidateId,
            fullName: parsedData.personalInfo.name,
            completionScore: 30,
          },
        });
      }

      for (const skillName of allSkills) {
        const skill = await tx.skill.findFirst({
          where: {
            OR: [
              { name: { equals: skillName, mode: 'insensitive' } },
              { aliases: { has: skillName.toLowerCase() } },
            ],
          },
        });

        if (skill) {
          await tx.candidateSkill.upsert({
            where: {
              candidateId_skillId: {
                candidateId: resume.candidateId,
                skillId: skill.id,
              },
            },
            update: { source: 'resume_parsed' },
            create: {
              candidateId: resume.candidateId,
              skillId: skill.id,
              proficiency: 50,
              source: 'resume_parsed',
            },
          });
        }
      }
    });
  } catch (error) {
    await prisma.resume.update({
      where: { id: resumeId },
      data: {
        parseStatus: 'FAILED',
        parseError: error instanceof Error ? error.message : 'Unknown error',
      },
    });
    throw error;
  } finally {
    if (tempFilePath) {
      await deleteLocalFile(tempFilePath);
    }
  }
}


===== FILE: ./src/modules/parser/preprocessor.ts =====
export function preprocessResumeText(rawText: string): string {
  return rawText
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/[ \t]+/g, ' ')
    .replace(/[^\x20-\x7E\n]/g, ' ')
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .replace(/â€¢\s*/g, 'â€¢ ')
    .replace(/([.!?])\s*([A-Z])/g, '$1\n$2')
    .trim();
}

export function truncateToTokenLimit(text: string, maxTokens: number = 6000): string {
  const maxChars = maxTokens * 4;
  if (text.length <= maxChars) return text;
  const start = text.slice(0, Math.floor(maxChars * 0.7));
  const end = text.slice(-Math.floor(maxChars * 0.3));
  return `${start}\n\n[...content truncated...]\n\n${end}`;
}


===== FILE: ./src/modules/parser/prompt.builder.ts =====
export const RESUME_PARSE_SYSTEM_PROMPT = `
You are an expert resume parser for an AI recruitment platform focused on Indian engineering freshers and early-career tech professionals.

Your task is to extract structured information from a resume and return ONLY a valid JSON object.
Do not include any explanation, markdown formatting, or text outside the JSON.

CRITICAL RULES:
1. Return ONLY valid JSON â€” no markdown blocks, no prose
2. Use null for missing fields, never omit them
3. Normalize skill names to their canonical form (e.g., "JS" â†’ "JavaScript", "py" â†’ "Python")
4. Extract ALL tech skills mentioned anywhere in the resume
5. For experience duration: calculate from dates if possible, estimate if only "2 years" mentioned
6. Flag bullet points that lack quantified achievements
7. Be conservative â€” if unsure, use null rather than guess

OUTPUT SCHEMA:
{
  "personalInfo": {
    "name": "string | null",
    "email": "string | null",
    "phone": "string | null",
    "location": "string | null",
    "linkedin": "string | null",
    "github": "string | null",
    "portfolio": "string | null"
  },
  "summary": "string | null",
  "experience": [
    {
      "company": "string",
      "role": "string",
      "startDate": "YYYY-MM | null",
      "endDate": "YYYY-MM | null | 'present'",
      "durationMonths": "number | null",
      "location": "string | null",
      "bullets": ["string"],
      "techStack": ["string"],
      "hasQuantifiedAchievements": "boolean"
    }
  ],
  "education": [
    {
      "institution": "string",
      "degree": "string",
      "branch": "string | null",
      "year": "number | null",
      "gpa": "number | null",
      "grade": "string | null"
    }
  ],
  "projects": [
    {
      "name": "string",
      "description": "string",
      "techStack": ["string"],
      "links": ["string"],
      "isOpenSource": "boolean"
    }
  ],
  "skills": {
    "languages": ["string"],
    "frameworks": ["string"],
    "databases": ["string"],
    "cloud": ["string"],
    "tools": ["string"],
    "methodologies": ["string"],
    "soft": ["string"]
  },
  "certifications": [
    {
      "name": "string",
      "issuer": "string | null",
      "year": "number | null"
    }
  ],
  "achievements": ["string"],
  "metrics": {
    "totalExperienceYears": "number",
    "projectCount": "number",
    "uniqueSkillCount": "number",
    "hasQuantifiedAchievements": "boolean",
    "hasSummary": "boolean",
    "hasLinkedin": "boolean",
    "hasGithub": "boolean",
    "estimatedSeniorityLevel": "fresher | junior | mid | senior"
  }
}
`;

export function buildParsePrompt(resumeText: string): string {
  return `Parse the following resume and return structured JSON exactly matching the schema.

RESUME TEXT:
---
${resumeText}
---

Return ONLY the JSON object. No other text.`;
}


===== FILE: ./src/modules/parser/response.validator.ts =====
import { z } from 'zod';

const PersonalInfoSchema = z.object({
  name: z.string().nullable(),
  email: z.string().email().nullable().optional(),
  phone: z.string().nullable().optional(),
  location: z.string().nullable().optional(),
  linkedin: z.string().nullable().optional(),
  github: z.string().nullable().optional(),
  portfolio: z.string().nullable().optional(),
});

const ExperienceSchema = z.array(
  z.object({
    company: z.string(),
    role: z.string(),
    startDate: z.string().nullable().optional(),
    endDate: z.string().nullable().optional(),
    durationMonths: z.number().nullable().optional(),
    location: z.string().nullable().optional(),
    bullets: z.array(z.string()),
    techStack: z.array(z.string()),
    hasQuantifiedAchievements: z.boolean(),
  })
);

const SkillsSchema = z.object({
  languages: z.array(z.string()),
  frameworks: z.array(z.string()),
  databases: z.array(z.string()),
  cloud: z.array(z.string()),
  tools: z.array(z.string()),
  methodologies: z.array(z.string()).optional().default([]),
  soft: z.array(z.string()).optional().default([]),
});

const MetricsSchema = z.object({
  totalExperienceYears: z.number().min(0).max(50),
  projectCount: z.number().min(0),
  uniqueSkillCount: z.number().min(0),
  hasQuantifiedAchievements: z.boolean(),
  hasSummary: z.boolean(),
  hasLinkedin: z.boolean(),
  hasGithub: z.boolean(),
  estimatedSeniorityLevel: z.enum(['fresher', 'junior', 'mid', 'senior']),
});

export const ParsedResumeSchema = z.object({
  personalInfo: PersonalInfoSchema,
  summary: z.string().nullable(),
  experience: ExperienceSchema,
  education: z.array(
    z.object({
      institution: z.string(),
      degree: z.string(),
      branch: z.string().nullable().optional(),
      year: z.number().nullable().optional(),
      gpa: z.number().nullable().optional(),
      grade: z.string().nullable().optional(),
    })
  ),
  projects: z.array(
    z.object({
      name: z.string(),
      description: z.string(),
      techStack: z.array(z.string()),
      links: z.array(z.string()),
      isOpenSource: z.boolean(),
    })
  ),
  skills: SkillsSchema,
  certifications: z.array(
    z.object({
      name: z.string(),
      issuer: z.string().nullable().optional(),
      year: z.number().nullable().optional(),
    })
  ),
  achievements: z.array(z.string()),
  metrics: MetricsSchema,
});

export type ParsedResume = z.infer<typeof ParsedResumeSchema>;

const defaultParsed: ParsedResume = {
  personalInfo: {
    name: null,
    email: null,
    phone: null,
    location: null,
    linkedin: null,
    github: null,
    portfolio: null,
  },
  summary: null,
  experience: [],
  education: [],
  projects: [],
  skills: {
    languages: [],
    frameworks: [],
    databases: [],
    cloud: [],
    tools: [],
    methodologies: [],
    soft: [],
  },
  certifications: [],
  achievements: [],
  metrics: {
    totalExperienceYears: 0,
    projectCount: 0,
    uniqueSkillCount: 0,
    hasQuantifiedAchievements: false,
    hasSummary: false,
    hasLinkedin: false,
    hasGithub: false,
    estimatedSeniorityLevel: 'fresher',
  },
};

export function validateParsedResume(raw: unknown): ParsedResume {
  const result = ParsedResumeSchema.safeParse(raw);

  if (result.success) {
    return result.data;
  }

  console.warn('AI output validation warnings:', result.error.flatten().fieldErrors);

  const recovered = ParsedResumeSchema.partial().safeParse(raw);
  if (recovered.success) {
    return { ...defaultParsed, ...recovered.data } as ParsedResume;
  }

  throw new Error(`AI resume parse output is completely invalid: ${result.error.message}`);
}


===== FILE: ./src/modules/parser/scorer.ts =====
import type { ParsedResume } from './response.validator';

export interface ScoringInput {
  parsedResume: ParsedResume;
  jobKeywords?: string[];
  jobSkills?: string[];
  targetRole?: string;
}

export interface ATSScore {
  total: number;
  breakdown: {
    skillsMatch: number;
    experienceRelevance: number;
    educationMatch: number;
    resumeQuality: number;
  };
  matchedKeywords: string[];
  missingKeywords: string[];
}

export function computeATSScore(input: ScoringInput): ATSScore {
  const { parsedResume, jobKeywords = [], jobSkills = [] } = input;

  const candidateSkills = [
    ...parsedResume.skills.languages,
    ...parsedResume.skills.frameworks,
    ...parsedResume.skills.databases,
    ...parsedResume.skills.tools,
    ...parsedResume.skills.cloud,
  ].map((s) => s.toLowerCase());

  const normalizedJobSkills = jobSkills.map((s) => s.toLowerCase());
  const matchedSkills = normalizedJobSkills.filter((s) =>
    candidateSkills.some((cs) => cs.includes(s) || s.includes(cs))
  );
  const skillsMatch =
    normalizedJobSkills.length > 0
      ? Math.round((matchedSkills.length / normalizedJobSkills.length) * 40)
      : 20;

  const experienceYears = parsedResume.metrics.totalExperienceYears;
  const experienceScore = Math.min(experienceYears * 5, 25);
  const experienceRelevance = Math.round(experienceScore);

  const hasRelevantDegree = parsedResume.education.some((e) =>
    ['b.tech', 'be', 'bsc', 'mca', 'm.tech', 'msc'].some((deg) =>
      e.degree.toLowerCase().includes(deg)
    )
  );
  const educationMatch = hasRelevantDegree ? 15 : 8;

  let qualityScore = 0;
  if (parsedResume.metrics.hasSummary) qualityScore += 4;
  if (parsedResume.metrics.hasLinkedin) qualityScore += 3;
  if (parsedResume.metrics.hasGithub) qualityScore += 3;
  if (parsedResume.metrics.hasQuantifiedAchievements) qualityScore += 5;
  if (parsedResume.projects.length >= 2) qualityScore += 5;
  const resumeQuality = Math.min(qualityScore, 20);

  const resumeText = JSON.stringify(parsedResume).toLowerCase();
  const matchedKeywords = jobKeywords.filter((k) =>
    resumeText.includes(k.toLowerCase())
  );
  const missingKeywords = jobKeywords.filter(
    (k) => !resumeText.includes(k.toLowerCase())
  );

  const total = Math.min(
    skillsMatch + experienceRelevance + educationMatch + resumeQuality,
    100
  );

  return {
    total,
    breakdown: {
      skillsMatch,
      experienceRelevance,
      educationMatch,
      resumeQuality,
    },
    matchedKeywords,
    missingKeywords,
  };
}


===== FILE: ./src/modules/resume/resume.controller.ts =====
import * as resumeService from './resume.service';
import { resumeIdParamSchema, analyzeForJobParamsSchema } from './resume.schema';
import { success } from '../../shared/utils/response';
import { UnauthorizedError } from '../../shared/errors';

function getCandidateId(request: any): string {
  const sub = request.user?.sub;
  if (!sub) throw new UnauthorizedError('Not authenticated');
  return sub;
}

export async function uploadHandler(request: any, reply: any) {
  const data = await request.file();
  if (!data) {
    return reply.status(400).send({ status: 'error', message: 'No file provided' });
  }

  const buffer = await data.toBuffer();
  const fileName = data.filename;
  const mimetype = data.mimetype;
  const candidateId = getCandidateId(request);

  const result = await resumeService.upload({
    buffer,
    fileName,
    mimetype,
    candidateId,
  });

  return success(reply, result, 201);
}

export async function getResumeHandler(request: any, reply: any) {
  const { id } = resumeIdParamSchema.parse(request.params);
  const candidateId = getCandidateId(request);
  const data = await resumeService.getResume(id, candidateId);
  return success(reply, data);
}

export async function getAtsScoreHandler(request: any, reply: any) {
  const { id } = resumeIdParamSchema.parse(request.params);
  const candidateId = getCandidateId(request);
  const data = await resumeService.getAtsScore(id, candidateId);
  return success(reply, data);
}

export async function getSuggestionsHandler(request: any, reply: any) {
  const { id } = resumeIdParamSchema.parse(request.params);
  const candidateId = getCandidateId(request);
  const data = await resumeService.getSuggestions(id, candidateId);
  return success(reply, data);
}

export async function analyzeForJobHandler(request: any, reply: any) {
  const { id: resumeId, jobId } = analyzeForJobParamsSchema.parse(request.params);
  const candidateId = getCandidateId(request);
  const data = await resumeService.analyzeForJob(resumeId, jobId, candidateId);
  return success(reply, data);
}


===== FILE: ./src/modules/resume/resume.repository.ts =====
import { prisma } from '../../infrastructure/db/prisma.client';
import type { ParseStatus } from '@prisma/client';

export async function createResume(data: {
  candidateId: string;
  fileName: string;
  fileUrl: string;
  fileType: string;
  fileSize: number;
  fileHash: string | null;
  version: number;
  parseStatus: ParseStatus;
}) {
  return prisma.resume.create({
    data: {
      ...data,
      extractedSkills: [],
    },
  });
}

export async function getResumeById(id: string, candidateId?: string) {
  const where: { id: string; candidateId?: string } = { id };
  if (candidateId) where.candidateId = candidateId;
  return prisma.resume.findFirst({
    where,
    include: { suggestions: true },
  });
}

export async function getActiveResume(candidateId: string) {
  return prisma.resume.findFirst({
    where: { candidateId, isActive: true },
    orderBy: { version: 'desc' },
  });
}

export async function deactivateResumes(candidateId: string) {
  return prisma.resume.updateMany({
    where: { candidateId, isActive: true },
    data: { isActive: false },
  });
}

export async function findLastVersion(candidateId: string) {
  return prisma.resume.findFirst({
    where: { candidateId },
    orderBy: { version: 'desc' },
  });
}

export async function findCompletedByHash(candidateId: string, fileHash: string) {
  return prisma.resume.findFirst({
    where: {
      candidateId,
      fileHash,
      parseStatus: 'COMPLETED',
    },
  });
}

export async function updateParseStatus(
  id: string,
  status: ParseStatus,
  error?: string | null,
  data?: {
    parsedData?: Record<string, unknown>;
    extractedSkills?: string[];
    atsScore?: number;
    yearsExperience?: number;
    parsedAt?: Date;
  }
) {
  return prisma.resume.update({
    where: { id },
    data: {
      parseStatus: status,
      parseError: error ?? undefined,
      ...(data && {
        parsedData: data.parsedData as any,
        extractedSkills: data.extractedSkills,
        atsScore: data.atsScore,
        yearsExperience: data.yearsExperience,
        parsedAt: data.parsedAt,
      }),
    },
  });
}


===== FILE: ./src/modules/resume/resume.routes.ts =====
import type { FastifyInstance } from 'fastify';
import {
  uploadHandler,
  getResumeHandler,
  getAtsScoreHandler,
  getSuggestionsHandler,
  analyzeForJobHandler,
} from './resume.controller';

export async function resumeRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.addHook('preHandler', f.authenticate);
  f.post('/upload', uploadHandler);
  f.get('/:id', getResumeHandler);
  f.get('/:id/ats-score', getAtsScoreHandler);
  f.get('/:id/suggestions', getSuggestionsHandler);
  f.post('/:id/analyze-for-job/:jobId', analyzeForJobHandler);
}


===== FILE: ./src/modules/resume/resume.schema.ts =====
import { z } from 'zod';

export const resumeIdParamSchema = z.object({
  id: z.string().min(1),
});

export const analyzeForJobParamsSchema = z.object({
  id: z.string().min(1),
  jobId: z.string().min(1),
});

export type ResumeIdParam = z.infer<typeof resumeIdParamSchema>;
export type AnalyzeForJobParams = z.infer<typeof analyzeForJobParamsSchema>;


===== FILE: ./src/modules/resume/resume.service.ts =====
import { createHash } from 'crypto';
import { ValidationError, NotFoundError } from '../../shared/errors';
import { prisma } from '../../infrastructure/db/prisma.client';
import { uploadResume as s3Upload } from '../../infrastructure/storage/s3.client';
import { MAX_RESUME_FILE_SIZE_BYTES, ALLOWED_RESUME_MIMES } from '../../config/constants';
import { resumeParsingQueue } from '../../infrastructure/queue/queues/resume.queue';
import * as resumeRepo from './resume.repository';

export interface UploadInput {
  buffer: Buffer;
  fileName: string;
  mimetype: string;
  candidateId: string;
}

async function validateFileMime(buffer: Buffer): Promise<void> {
  const { fileTypeFromBuffer } = await import('file-type');
  const type = await fileTypeFromBuffer(buffer);
  if (!type || !ALLOWED_RESUME_MIMES.includes(type.mime as any)) {
    throw new ValidationError(
      `Invalid file type: ${type?.mime ?? 'unknown'}. Only PDF and DOCX are allowed.`
    );
  }
}

export async function upload(input: UploadInput) {
  if (input.buffer.length > MAX_RESUME_FILE_SIZE_BYTES) {
    throw new ValidationError(`File size exceeds ${MAX_RESUME_FILE_SIZE_BYTES / 1024 / 1024}MB`);
  }

  await validateFileMime(input.buffer);

  const fileHash = createHash('sha256').update(input.buffer).digest('hex');

  const existing = await resumeRepo.findCompletedByHash(input.candidateId, fileHash);
  if (existing) {
    return {
      resumeId: existing.id,
      version: existing.version,
      parseStatus: 'COMPLETED',
      cached: true,
      message: 'This resume was previously uploaded and parsed.',
    };
  }

  await resumeRepo.deactivateResumes(input.candidateId);
  const lastResume = await resumeRepo.findLastVersion(input.candidateId);
  const newVersion = (lastResume?.version ?? 0) + 1;

  const fileType = input.fileName.toLowerCase().endsWith('.pdf') ? 'pdf' : 'docx';
  const contentType =
    fileType === 'pdf'
      ? 'application/pdf'
      : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';

  const fileUrl = await s3Upload(
    input.buffer,
    input.candidateId,
    input.fileName,
    contentType
  );

  const resume = await resumeRepo.createResume({
    candidateId: input.candidateId,
    fileName: input.fileName,
    fileUrl,
    fileType,
    fileSize: input.buffer.length,
    fileHash,
    version: newVersion,
    parseStatus: 'PENDING',
  });

  await resumeParsingQueue.add('parse', { resumeId: resume.id });

  return {
    resumeId: resume.id,
    version: newVersion,
    parseStatus: 'PENDING',
  };
}

export async function getResume(id: string, candidateId: string) {
  const resume = await resumeRepo.getResumeById(id, candidateId);
  if (!resume) throw new NotFoundError('Resume not found');
  return resume;
}

export async function getAtsScore(id: string, candidateId: string) {
  const resume = await resumeRepo.getResumeById(id, candidateId);
  if (!resume) throw new NotFoundError('Resume not found');
  return {
    atsScore: resume.atsScore,
    parseStatus: resume.parseStatus,
  };
}

export async function getSuggestions(id: string, candidateId: string) {
  const resume = await resumeRepo.getResumeById(id, candidateId);
  if (!resume) throw new NotFoundError('Resume not found');
  return resume.suggestions;
}

export async function analyzeForJob(
  resumeId: string,
  jobId: string,
  candidateId: string
) {
  const resume = await resumeRepo.getResumeById(resumeId, candidateId);
  if (!resume) throw new NotFoundError('Resume not found');
  if (resume.parseStatus !== 'COMPLETED' || !resume.parsedData) {
    throw new ValidationError('Resume must be parsed before analyzing for a job');
  }

  const job = await prisma.job.findUnique({
    where: { id: jobId, status: 'ACTIVE' },
    include: { requiredSkills: { include: { skill: true } } },
  });
  if (!job) throw new NotFoundError('Job not found');

  const { computeATSScore } = await import('../parser/scorer');
  const jobSkills = job.requiredSkills.map((js) => js.skill.name);
  const atsResult = computeATSScore({
    parsedResume: resume.parsedData as any,
    jobKeywords: job.keywords,
    jobSkills,
  });

  await prisma.jobAtsScore.upsert({
    where: {
      resumeId_jobId: { resumeId, jobId },
    },
    update: {
      score: atsResult.total,
      matchedKeywords: atsResult.matchedKeywords,
      missingKeywords: atsResult.missingKeywords,
      breakdown: atsResult.breakdown as any,
    },
    create: {
      resumeId,
      jobId,
      score: atsResult.total,
      matchedKeywords: atsResult.matchedKeywords,
      missingKeywords: atsResult.missingKeywords,
      breakdown: atsResult.breakdown as any,
    },
  });

  return atsResult;
}


===== FILE: ./src/modules/scoring/__tests__/ats.engine.test.ts =====
import { describe, it, expect } from 'vitest';
import {
  scoreSkills,
  scoreExperience,
  scoreEducation,
  scoreCompleteness,
  scoreBonus,
  computeFinalScore,
  scoreResumeAgainstJob,
} from '@/modules/scoring/ats.engine';
import { MAX_KEYWORDS } from '@/modules/scoring/scoring.constants';
import type { JobInput, ResumeInput, ScoringContext } from '@/modules/scoring/scoring.types';

describe('scoreSkills', () => {
  it('returns 100 when all required skills matched', () => {
    const result = scoreSkills(['js', 'ts'], ['js', 'ts'], 0.4);
    expect(result.score).toBe(100);
    expect(result.matched.sort()).toEqual(['js', 'ts']);
    expect(result.missing).toEqual([]);
  });

  it('returns 0 when no skills matched', () => {
    const result = scoreSkills(['go'], ['js', 'ts'], 0.4);
    expect(result.score).toBe(0);
    expect(result.matched).toEqual([]);
    expect(result.missing.sort()).toEqual(['js', 'ts']);
  });

  it('returns partial score proportional to matched count', () => {
    const result = scoreSkills(['js'], ['js', 'ts'], 0.4);
    expect(result.score).toBe(50);
  });

  it('is case-insensitive (normalizes before comparison)', () => {
    const result = scoreSkills(['JavaScript'], ['javascript'], 0.4);
    expect(result.score).toBe(100);
  });

  it('handles empty required skills array gracefully', () => {
    const result = scoreSkills(['js'], [], 0.4);
    expect(result.score).toBe(0);
    expect(result.matched).toEqual([]);
    expect(result.missing).toEqual([]);
  });

  it('caps keyword processing at MAX_KEYWORDS', () => {
    const resumeSkills = Array.from({ length: MAX_KEYWORDS + 10 }, (_, i) => `skill-${i}`);
    const requiredSkills = Array.from({ length: MAX_KEYWORDS + 10 }, (_, i) => `skill-${i}`);

    const result = scoreSkills(resumeSkills, requiredSkills, 0.4);
    expect(result.score).toBe(100);
  });
});

describe('scoreExperience', () => {
  it('returns full score when years >= required', () => {
    expect(scoreExperience(5, 5, 0.2)).toBe(100);
    expect(scoreExperience(6, 5, 0.2)).toBe(100);
  });

  it('returns partial score within 1yr gap', () => {
    expect(scoreExperience(3, 4, 0.2)).toBe(60);
  });

  it('returns 0 when years far below required', () => {
    expect(scoreExperience(1, 5, 0.2)).toBe(0);
  });

  it('handles zero required years', () => {
    expect(scoreExperience(0, 0, 0.2)).toBe(100);
  });
});

describe('scoreEducation', () => {
  it('returns 100 when level meets or exceeds requirement', () => {
    expect(scoreEducation('bachelor', 'associate', 0.2)).toBe(100);
    expect(scoreEducation('master', 'bachelor', 0.2)).toBe(100);
  });

  it('returns 0 when level is below requirement', () => {
    expect(scoreEducation('associate', 'bachelor', 0.2)).toBe(0);
  });

  it('handles unknown education level as none', () => {
    expect(scoreEducation('unknown-level', 'associate', 0.2)).toBe(0);
  });
});

describe('scoreCompleteness', () => {
  it('returns 100 when all sections present', () => {
    const resume: ResumeInput = {
      skills: ['a'],
      experience: { years: 1 },
      education: { level: 'bachelor' },
      summary: 'summary',
    };
    expect(scoreCompleteness(resume, 0.1)).toBe(100);
  });

  it('returns proportional score for partial sections', () => {
    const resume: ResumeInput = {
      skills: ['a'],
      experience: { years: 1 },
      education: { level: 'bachelor' },
      summary: '',
    };
    expect(scoreCompleteness(resume, 0.1)).toBe(75);
  });

  it('handles empty resume object', () => {
    expect(scoreCompleteness({} as unknown as ResumeInput, 0.1)).toBe(0);
  });
});

describe('scoreBonus', () => {
  it('caps bonus at max regardless of items count', () => {
    const resume: ResumeInput = {
      skills: ['a'],
      experience: { years: 1 },
      education: { level: 'bachelor' },
      summary: 'summary',
      certifications: ['c1'],
      projects: ['p1'],
      publications: ['pub1'],
      awards: ['a1'],
    };
    expect(scoreBonus(resume, 0.1)).toBe(100);
  });

  it('returns 0 when no bonus items present', () => {
    const resume: ResumeInput = {
      skills: ['a'],
      experience: { years: 1 },
      education: { level: 'bachelor' },
      summary: 'summary',
    };
    expect(scoreBonus(resume, 0.1)).toBe(0);
  });
});

describe('computeFinalScore', () => {
  it('always returns integer', () => {
    const score = computeFinalScore([33.3, 33.3, 33.3]);
    expect(Number.isInteger(score)).toBe(true);
  });

  it('clamps to 0 minimum', () => {
    expect(computeFinalScore([-10])).toBe(0);
  });

  it('clamps to 100 maximum', () => {
    expect(computeFinalScore([120])).toBe(100);
  });

  it('rounds 0.5 up', () => {
    expect(computeFinalScore([0.5])).toBe(1);
  });
});

describe('scoreResumeAgainstJob (integration)', () => {
  it('returns deterministic result for same inputs', () => {
    const resume: ResumeInput = {
      skills: ['JavaScript', 'TypeScript'],
      experience: { years: 3 },
      education: { level: 'bachelor' },
      summary: 'summary',
    };

    const job: JobInput = {
      requiredSkills: ['javascript', 'typescript'],
      preferredSkills: [],
      requiredExperienceYears: 3,
      requiredEducationLevel: 'bachelor',
      title: 'Fullstack Engineer',
      description: 'desc',
    };

    const context: ScoringContext = {
      tenantId: 't1',
      jobId: 'j1',
      resumeId: 'r1',
    };

    const first = scoreResumeAgainstJob(resume, job, context);
    const second = scoreResumeAgainstJob(resume, job, context);

    expect(first).toEqual(second);
  });

  it('returns full ScoringResult shape', () => {
    const resume: ResumeInput = {
      skills: ['JavaScript', 'TypeScript'],
      experience: { years: 3 },
      education: { level: 'bachelor' },
      summary: 'summary',
    };

    const job: JobInput = {
      requiredSkills: ['javascript'],
      preferredSkills: [],
      requiredExperienceYears: 1,
      requiredEducationLevel: 'associate',
      title: 'Engineer',
      description: 'desc',
    };

    const context: ScoringContext = {
      tenantId: 't1',
      jobId: 'j1',
      resumeId: 'r1',
    };

    const result = scoreResumeAgainstJob(resume, job, context);

    expect(typeof result.score).toBe('number');
    expect(result.breakdown).toBeDefined();
    expect(Array.isArray(result.matchedKeywords)).toBe(true);
    expect(Array.isArray(result.missingKeywords)).toBe(true);
    expect(Array.isArray(result.suggestions)).toBe(true);
    expect(result.metadata).toBeDefined();
  });

  it('does not throw on malformed input â€” returns score: 0', () => {
    const resume = {} as unknown as ResumeInput;
    const job = {} as unknown as JobInput;
    const context: ScoringContext = {
      tenantId: 't1',
      jobId: 'j1',
      resumeId: 'r1',
    };

    const result = scoreResumeAgainstJob(resume, job, context);
    expect(result.score).toBe(0);
  });

  it('processes 1000 keyword arrays in under 10ms', () => {
    const resume: ResumeInput = {
      skills: Array.from({ length: 1000 }, (_, i) => `skill-${i}`),
      experience: { years: 5 },
      education: { level: 'bachelor' },
      summary: 'summary',
    };

    const job: JobInput = {
      requiredSkills: Array.from({ length: 1000 }, (_, i) => `skill-${i}`),
      preferredSkills: [],
      requiredExperienceYears: 3,
      requiredEducationLevel: 'associate',
      title: 'Engineer',
      description: 'desc',
    };

    const context: ScoringContext = {
      tenantId: 't1',
      jobId: 'j1',
      resumeId: 'r1',
    };

    const start = performance.now();
    for (let i = 0; i < 1000; i += 1) {
      scoreResumeAgainstJob(resume, job, context);
    }
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(10);
  });
});



===== FILE: ./src/modules/scoring/__tests__/scoring.cache.test.ts =====
import { describe, it, expect } from 'vitest';
import Redis from 'ioredis-mock';
import { getCachedScore, setCachedScore, computeResumeHash } from '@/modules/scoring/scoring.cache';
import type { ResumeInput, ScoringResult } from '@/modules/scoring/scoring.types';
import { CACHE_TTL_SECONDS } from '@/modules/scoring/scoring.constants';

describe('getCachedScore', () => {
  it('returns null on cache miss', async () => {
    const redis = new Redis();
    const resume: ResumeInput = {
      skills: [],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const result = await getCachedScore(redis as any, 'tenant', 'job', resume);
    expect(result).toBeNull();
  });

  it('returns parsed ScoringResult on cache hit', async () => {
    const redis = new Redis();
    const resume: ResumeInput = {
      skills: [],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const score: ScoringResult = {
      score: 80,
      breakdown: {
        skillScore: 80,
        experienceScore: 80,
        educationScore: 80,
        completenessScore: 80,
        bonusScore: 80,
      },
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs: 1,
        version: 'v1.0.0',
        cacheHit: false,
      },
    };

    await setCachedScore(redis as any, 'tenant', 'job', resume, score);

    const result = await getCachedScore(redis as any, 'tenant', 'job', resume);
    expect(result).not.toBeNull();
    expect(result?.score).toBe(80);
    expect(result?.metadata.cacheHit).toBe(true);
  });

  it('returns null (not throws) on Redis error', async () => {
    const redis = {
      get: () => {
        throw new Error('redis failure');
      },
    } as any;

    const resume: ResumeInput = {
      skills: [],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const result = await getCachedScore(redis, 'tenant', 'job', resume);
    expect(result).toBeNull();
  });
});

describe('setCachedScore', () => {
  it('stores result with correct TTL', async () => {
    const redis = new Redis();
    const resume: ResumeInput = {
      skills: [],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const score: ScoringResult = {
      score: 80,
      breakdown: {
        skillScore: 80,
        experienceScore: 80,
        educationScore: 80,
        completenessScore: 80,
        bonusScore: 80,
      },
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs: 1,
        version: 'v1.0.0',
        cacheHit: false,
      },
    };

    await setCachedScore(redis as any, 'tenant', 'job', resume, score);

    const keys = await redis.keys('*');
    expect(keys.length).toBe(1);
    const ttl = await redis.ttl(keys[0]);
    expect(ttl).toBeGreaterThanOrEqual(CACHE_TTL_SECONDS);
    expect(ttl).toBeLessThanOrEqual(CACHE_TTL_SECONDS + 180);
  });

  it('uses deterministic cache key for same resume', async () => {
    const redis = new Redis();
    const resume: ResumeInput = {
      skills: ['b', 'a'],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const score: ScoringResult = {
      score: 80,
      breakdown: {
        skillScore: 80,
        experienceScore: 80,
        educationScore: 80,
        completenessScore: 80,
        bonusScore: 80,
      },
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs: 1,
        version: 'v1.0.0',
        cacheHit: false,
      },
    };

    await setCachedScore(redis as any, 'tenant', 'job', resume, score);
    await setCachedScore(redis as any, 'tenant', 'job', resume, score);

    const keys = await redis.keys('*');
    expect(keys.length).toBe(1);
  });

  it('silently fails (not throws) on Redis error', async () => {
    const redis = {
      set: () => {
        throw new Error('redis failure');
      },
    } as any;

    const resume: ResumeInput = {
      skills: [],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const score: ScoringResult = {
      score: 80,
      breakdown: {
        skillScore: 80,
        experienceScore: 80,
        educationScore: 80,
        completenessScore: 80,
        bonusScore: 80,
      },
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs: 1,
        version: 'v1.0.0',
        cacheHit: false,
      },
    };

    await expect(
      setCachedScore(redis, 'tenant', 'job', resume, score),
    ).resolves.toBeUndefined();
  });
});

describe('computeResumeHash', () => {
  it('produces same hash regardless of skills array order', () => {
    const resumeA: ResumeInput = {
      skills: ['a', 'b'],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };
    const resumeB: ResumeInput = {
      skills: ['b', 'a'],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const hashA = computeResumeHash(resumeA);
    const hashB = computeResumeHash(resumeB);
    expect(hashA).toBe(hashB);
  });

  it('produces different hash for different resume content', () => {
    const resumeA: ResumeInput = {
      skills: ['a'],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };
    const resumeB: ResumeInput = {
      skills: ['b'],
      experience: { years: 0 },
      education: { level: 'none' },
      summary: 's',
    };

    const hashA = computeResumeHash(resumeA);
    const hashB = computeResumeHash(resumeB);
    expect(hashA).not.toBe(hashB);
  });
});



===== FILE: ./src/modules/scoring/ats.engine.ts =====
import {
  BONUS_ITEMS,
  EDUCATION_LEVELS,
  MAX_KEYWORDS,
  MAX_TOTAL_BONUS,
  REQUIRED_RESUME_SECTIONS,
  SCORE_WEIGHTS,
  SCORING_VERSION,
} from '@/modules/scoring/scoring.constants';
import {
  buildKeywordSet,
  diffSets,
  intersectSets,
  normalizeEducationLevel,
  normalizeKeyword,
  safeTruncate,
  buildSuggestions,
} from '@/modules/scoring/normalization.utils';
import type { JobInput, ResumeInput, ScoringContext, ScoringResult, ScoreBreakdown, WeightStrategy } from '@/modules/scoring/scoring.types';

/**
 * === HORIZONTAL SCALING STRATEGY ===
 *
 * This engine is a pure function â€” no shared state, no DB, no Redis.
 * This means:
 * 1. Any K8s pod can serve any request â€” no sticky sessions required
 * 2. Scaling = adding pods. No coordination overhead.
 * 3. Weighted scoring recomputation is O(n) in keyword count â€” CPU-bound workload
 *    that benefits from multiple cores via K8s pod autoscaling (HPA on CPU metric)
 *
 * === CACHE ARCHITECTURE (L1 + L2) ===
 *
 * L1: In-process LRU (node-lru-cache, max 1000 entries, ~10MB)
 *     - Absorbs hot-key bursts without hitting Redis
 *     - Invalidated on pod restart (acceptable â€” L2 persists)
 * L2: Redis Cluster with {tenantId} hashtag slot affinity
 *     - Ensures tenant data is co-located on same shard
 *     - Prevents cross-slot operations
 *
 * === MEMORY SAFETY ===
 *
 * - MAX_PAYLOAD_BYTES guard prevents string explosion attacks
 * - MAX_KEYWORDS cap prevents O(nÂ²) Set intersection on malicious payloads
 * - All arrays are `.slice(0, MAX_KEYWORDS)` before processing
 * - No regex catastrophic backtracking â€” only String.prototype methods used
 * - Buffer.byteLength used for accurate byte counting (handles multibyte UTF-8)
 *
 * === ENGINE VERSIONING ===
 *
 * SCORING_VERSION is embedded in every response.metadata.
 * To introduce v2 scoring:
 * 1. Create src/modules/scoring/v2/ats.engine.ts
 * 2. Add version routing in scoring.service.ts based on tenant feature flag
 * 3. v1 results remain cached under v1 keys â€” no cache pollution
 * 4. Shadow mode: run both engines, log diff, validate before cutover
 */

/**
 * Compute the final weighted score for a resume against a job description.
 *
 * SCALING NOTE: this function is intentionally pure and CPU-bound. It does
 * not allocate shared state or perform any I/O, which allows horizontal
 * scaling across pods without coordination.
 *
 * @param resume - Parsed resume input.
 * @param job - Parsed job description input.
 * @param context - Scoring context including tenant and IDs.
 * @returns Complete scoring result, never throws.
 * @pure
 */
export function scoreResumeAgainstJob(
  resume: ResumeInput,
  job: JobInput,
  context: ScoringContext,
): ScoringResult {
  try {
    const effectiveWeights: Required<WeightStrategy> = {
      skill: context.weights?.skill ?? SCORE_WEIGHTS.skill,
      experience: context.weights?.experience ?? SCORE_WEIGHTS.experience,
      education: context.weights?.education ?? SCORE_WEIGHTS.education,
      completeness: context.weights?.completeness ?? SCORE_WEIGHTS.completeness,
      bonus: context.weights?.bonus ?? SCORE_WEIGHTS.bonus,
    } as Required<WeightStrategy>;

    const resumeSkills = (resume.skills ?? []).slice(0, MAX_KEYWORDS).map((s) => normalizeKeyword(safeTruncate(s)));
    const requiredSkills = (job.requiredSkills ?? [])
      .slice(0, MAX_KEYWORDS)
      .map((s) => normalizeKeyword(safeTruncate(s)));

    const skillResult = scoreSkills(resumeSkills, requiredSkills, effectiveWeights.skill);

    const experienceScore = scoreExperience(
      resume.experience?.years ?? 0,
      job.requiredExperienceYears,
      effectiveWeights.experience,
    );

    const educationScore = scoreEducation(
      resume.education?.level ?? 'none',
      job.requiredEducationLevel,
      effectiveWeights.education,
    );

    const completenessScore = scoreCompleteness(resume, effectiveWeights.completeness);
    const bonusScore = scoreBonus(resume, effectiveWeights.bonus);

    const breakdown: ScoreBreakdown = {
      skillScore: skillResult.score,
      experienceScore,
      educationScore,
      completenessScore,
      bonusScore,
    };

    const weightedComponents: number[] = [
      breakdown.skillScore * effectiveWeights.skill,
      breakdown.experienceScore * effectiveWeights.experience,
      breakdown.educationScore * effectiveWeights.education,
      breakdown.completenessScore * effectiveWeights.completeness,
      breakdown.bonusScore * effectiveWeights.bonus,
    ];

    const finalScore = computeFinalScore(weightedComponents);

    const suggestions = buildSuggestions(breakdown, skillResult.missing, effectiveWeights);

    return {
      score: finalScore,
      breakdown,
      matchedKeywords: skillResult.matched,
      missingKeywords: skillResult.missing,
      suggestions,
      metadata: {
        processingTimeMs: 0,
        version: SCORING_VERSION,
        cacheHit: false,
      },
    };
  } catch {
    // Defensive fallback â€“ never throw from engine.
    const zeroBreakdown: ScoreBreakdown = {
      skillScore: 0,
      experienceScore: 0,
      educationScore: 0,
      completenessScore: 0,
      bonusScore: 0,
    };

    return {
      score: 0,
      breakdown: zeroBreakdown,
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs: 0,
        version: SCORING_VERSION,
        cacheHit: false,
      },
    };
  }
}

/**
 * Score skills by computing overlap between resume and required skills.
 *
 * @param resumeSkills - Normalized resume skills.
 * @param requiredSkills - Normalized required skills.
 * @param _weight - Component weight (reserved for future use).
 * @returns Object containing score, matched, and missing keywords.
 * @pure
 */
export function scoreSkills(
  resumeSkills: string[],
  requiredSkills: string[],
  _weight: number,
): { score: number; matched: string[]; missing: string[] } {
  if (!requiredSkills || requiredSkills.length === 0) {
    return { score: 0, matched: [], missing: [] };
  }

  const resumeSet = buildKeywordSet(resumeSkills, MAX_KEYWORDS);
  const requiredSet = buildKeywordSet(requiredSkills, MAX_KEYWORDS);

  const matched = intersectSets(resumeSet, requiredSet);
  const missing = diffSets(requiredSet, resumeSet);

  const totalRequired = requiredSet.size || 1;
  const ratio = matched.length / totalRequired;
  const rawScore = Math.round(ratio * 100);

  return {
    score: rawScore,
    matched,
    missing,
  };
}

/**
 * Score experience based on years relative to job requirement.
 *
 * @param resumeYears - Years of candidate experience.
 * @param requiredYears - Required years of experience for the job.
 * @param _weight - Component weight (reserved for future use).
 * @returns Experience score between 0 and 100.
 * @pure
 */
export function scoreExperience(resumeYears: number, requiredYears: number, _weight: number): number {
  if (requiredYears <= 0) {
    return 100;
  }

  const safeResumeYears = Number.isFinite(resumeYears) && resumeYears >= 0 ? resumeYears : 0;

  if (safeResumeYears >= requiredYears) {
    return 100;
  }

  if (safeResumeYears >= requiredYears * 0.75) {
    return 80;
  }

  if (safeResumeYears >= requiredYears - 1) {
    return 60;
  }

  return 0;
}

/**
 * Score education by comparing normalized levels against requirements.
 *
 * @param resumeLevel - Candidate education level.
 * @param requiredLevel - Required education level for the job.
 * @param _weight - Component weight (reserved for future use).
 * @returns Education score between 0 and 100.
 * @pure
 */
export function scoreEducation(resumeLevel: string, requiredLevel: string, _weight: number): number {
  const normalizedResume = normalizeEducationLevel(resumeLevel);
  const normalizedRequired = normalizeEducationLevel(requiredLevel);

  const resumeOrdinal = EDUCATION_LEVELS[normalizedResume];
  const requiredOrdinal = EDUCATION_LEVELS[normalizedRequired];

  if (resumeOrdinal >= requiredOrdinal) {
    return 100;
  }

  return 0;
}

/**
 * Score resume completeness based on presence of required sections.
 *
 * @param resume - Resume input object.
 * @param _weight - Component weight (reserved for future use).
 * @returns Completeness score between 0 and 100.
 * @pure
 */
export function scoreCompleteness(resume: ResumeInput, _weight: number): number {
  if (!resume) {
    return 0;
  }

  let present = 0;

  for (const section of REQUIRED_RESUME_SECTIONS) {
    const value = (resume as unknown as Record<string, unknown>)[section];

    if (Array.isArray(value) && value.length > 0) {
      present += 1;
    } else if (value && typeof value === 'object') {
      present += 1;
    } else if (typeof value === 'string' && value.trim().length > 0) {
      present += 1;
    }
  }

  const ratio = present / REQUIRED_RESUME_SECTIONS.length;
  return Math.round(ratio * 100);
}

/**
 * Score bonus items such as certifications, projects, publications, and awards.
 *
 * @param resume - Resume input object.
 * @param _weight - Component weight (reserved for future use).
 * @returns Bonus score between 0 and 100.
 * @pure
 */
export function scoreBonus(resume: ResumeInput, _weight: number): number {
  if (!resume) {
    return 0;
  }

  let bonusFraction = 0;

  for (const item of BONUS_ITEMS) {
    const value = (resume as unknown as Record<string, unknown>)[item];
    const hasValue =
      (Array.isArray(value) && value.length > 0) ||
      (typeof value === 'string' && value.trim().length > 0);

    if (hasValue) {
      bonusFraction += MAX_TOTAL_BONUS / BONUS_ITEMS.length;
    }
  }

  if (bonusFraction > MAX_TOTAL_BONUS) {
    bonusFraction = MAX_TOTAL_BONUS;
  }

  return Math.round((bonusFraction / MAX_TOTAL_BONUS) * 100);
}

/**
 * Clamp and round a weighted component sum into the integer range 0â€“100.
 *
 * @param weightedComponents - Array of weighted component scores.
 * @returns Final clamped integer score.
 * @pure
 */
export function computeFinalScore(weightedComponents: number[]): number {
  const sum = weightedComponents.reduce((acc, value) => acc + (Number.isFinite(value) ? value : 0), 0);
  const rounded = Math.round(sum);
  if (Number.isNaN(rounded)) {
    return 0;
  }

  return Math.min(100, Math.max(0, rounded));
}



===== FILE: ./src/modules/scoring/normalization.utils.ts =====
import { EDUCATION_LEVELS, MAX_KEYWORDS, MAX_PAYLOAD_BYTES } from '@/modules/scoring/scoring.constants';
import type { ScoreBreakdown, WeightStrategy } from '@/modules/scoring/scoring.types';

/**
 * Normalize a single keyword by trimming, lowercasing, and collapsing
 * internal whitespace.
 *
 * @param raw - Raw keyword input.
 * @returns Normalized keyword string.
 * @pure
 */
export function normalizeKeyword(raw: string): string {
  const trimmed = raw.trim().toLowerCase();

  // For short keyword strings this regex is safe and fast.
  // Avoids using /regex/g with .exec() in a loop on large payloads.
  return trimmed.replace(/\s+/g, ' ');
}

/**
 * Normalize an array of keywords and build a Set in a single O(n) pass.
 *
 * Caps processing at MAX_KEYWORDS to protect against malicious payloads.
 *
 * @param keywords - Array of raw keyword strings.
 * @param limit - Optional per-call keyword cap (defaults to MAX_KEYWORDS).
 * @returns Set of normalized, lowercased keywords.
 * @pure
 */
export function buildKeywordSet(keywords: string[], limit: number = MAX_KEYWORDS): Set<string> {
  const effectiveLimit = Math.min(limit, MAX_KEYWORDS);
  const set = new Set<string>();

  const count = Math.min(keywords.length, effectiveLimit);
  for (let i = 0; i < count; i += 1) {
    const normalized = normalizeKeyword(keywords[i]);
    if (normalized.length > 0) {
      set.add(normalized);
    }
  }

  return set;
}

/**
 * Compute the intersection of two Sets in O(min(a, b)).
 *
 * @param a - First keyword set.
 * @param b - Second keyword set.
 * @returns Array of intersecting elements.
 * @pure
 */
export function intersectSets(a: Set<string>, b: Set<string>): string[] {
  const [smaller, larger] = a.size <= b.size ? [a, b] : [b, a];
  const result: string[] = [];

  // Pre-allocation is avoided here because the final size is unknown,
  // but push operations on arrays are amortized O(1).
  for (const value of smaller) {
    if (larger.has(value)) {
      result.push(value);
    }
  }

  return result;
}

/**
 * Compute the set difference a \ b in O(|a|).
 *
 * @param a - Source set.
 * @param b - Elements to exclude.
 * @returns Array of elements in a but not in b.
 * @pure
 */
export function diffSets(a: Set<string>, b: Set<string>): string[] {
  const result: string[] = [];

  for (const value of a) {
    if (!b.has(value)) {
      result.push(value);
    }
  }

  return result;
}

/**
 * Safely truncate a string by byte length rather than character count.
 *
 * Uses Buffer.byteLength for accurate UTF-8 byte counting and ensures
 * the result does not exceed the specified byte budget.
 *
 * @param input - Input string to truncate.
 * @param maxBytes - Maximum allowed bytes (defaults to MAX_PAYLOAD_BYTES).
 * @returns Truncated string that fits within the byte budget.
 * @pure
 */
export function safeTruncate(input: string, maxBytes: number = MAX_PAYLOAD_BYTES): string {
  if (Buffer.byteLength(input, 'utf8') <= maxBytes) {
    return input;
  }

  let bytes = 0;
  let endIndex = 0;

  // Iterate code units and stop before exceeding maxBytes.
  for (let i = 0; i < input.length; i += 1) {
    const char = input[i];
    const charBytes = Buffer.byteLength(char, 'utf8');

    if (bytes + charBytes > maxBytes) {
      break;
    }

    bytes += charBytes;
    endIndex = i + 1;
  }

  return input.slice(0, endIndex);
}

/**
 * Normalize education level strings to known EDUCATION_LEVELS keys.
 *
 * Returns 'none' as a safe fallback for unknown or malformed input.
 *
 * @param raw - Raw education level string.
 * @returns Normalized education level key.
 * @pure
 */
export function normalizeEducationLevel(raw: string): keyof typeof EDUCATION_LEVELS {
  const value = raw.trim().toLowerCase();

  // Direct match against known keys.
  if (value in EDUCATION_LEVELS) {
    return value as keyof typeof EDUCATION_LEVELS;
  }

  // Simple synonym mapping for robustness.
  if (value.includes('associate')) return 'associate';
  if (value.includes('bachelor') || value.includes('bsc') || value.includes('b.tech') || value.includes('be')) {
    return 'bachelor';
  }
  if (value.includes('master') || value.includes('msc') || value.includes('m.tech') || value.includes('ma')) {
    return 'master';
  }
  if (value.includes('phd') || value.includes('doctor')) {
    return 'phd';
  }

  return 'none';
}

/**
 * Build human-readable suggestion strings from score gaps and missing keywords.
 *
 * This function is intentionally heuristic but deterministic. It only
 * consumes the breakdown, missingKeywords, and weight configuration
 * to produce actionable improvement hints for candidates.
 *
 * @param breakdown - Component score breakdown.
 * @param missingKeywords - Normalized list of missing keywords.
 * @param weights - Effective weight strategy for this request.
 * @returns Array of suggestion strings.
 * @pure
 */
export function buildSuggestions(
  breakdown: ScoreBreakdown,
  missingKeywords: string[],
  weights: WeightStrategy,
): string[] {
  const suggestions: string[] = [];

  const effectiveWeights: WeightStrategy = { ...weights };

  // Skills
  if (breakdown.skillScore < 80 && (effectiveWeights.skill ?? 0) > 0) {
    suggestions.push(
      'Highlight more of the required skills in your resume, ensuring terminology matches the job description.',
    );
  }

  if (missingKeywords.length > 0) {
    const sampleMissing = missingKeywords.slice(0, 5).join(', ');
    suggestions.push(
      `Consider adding experience or keywords related to: ${sampleMissing}. Only include items that genuinely reflect your background.`,
    );
  }

  // Experience
  if (breakdown.experienceScore < 80 && (effectiveWeights.experience ?? 0) > 0) {
    suggestions.push(
      'Emphasize roles and achievements that demonstrate years of experience relevant to this position.',
    );
  }

  // Education
  if (breakdown.educationScore < 80 && (effectiveWeights.education ?? 0) > 0) {
    suggestions.push(
      'Clarify your highest education level and ensure your degree information is clearly listed in the education section.',
    );
  }

  // Completeness
  if (breakdown.completenessScore < 100 && (effectiveWeights.completeness ?? 0) > 0) {
    suggestions.push(
      'Complete all core sections of your resume, including skills, experience, education, and a concise professional summary.',
    );
  }

  // Bonus items
  if (breakdown.bonusScore < 100 && (effectiveWeights.bonus ?? 0) > 0) {
    suggestions.push(
      'Add relevant certifications, projects, publications, or awards to unlock additional bonus score and stand out.',
    );
  }

  return suggestions;
}



===== FILE: ./src/modules/scoring/scoring.benchmark.ts =====
import { performance } from 'node:perf_hooks';
import { scoreResumeAgainstJob } from '@/modules/scoring/ats.engine';
import type { JobInput, ResumeInput, ScoringContext } from '@/modules/scoring/scoring.types';

/**
 * Run a synthetic benchmark of the pure scoring engine.
 *
 * Simulates load of N scoring calls and reports latency percentiles and throughput.
 *
 * @param iterations - Number of scoring calls to execute.
 * @returns Promise that resolves when the benchmark completes.
 */
export async function runBenchmark(iterations: number = 10_000): Promise<void> {
  const batchSize = 500;
  const latencies: number[] = [];

  const resume: ResumeInput = {
    skills: Array.from({ length: 100 }, (_, i) => `skill-${i}`),
    experience: { years: 5 },
    education: { level: 'bachelor' },
    summary: 'Experienced engineer with a strong background in TypeScript and Node.js.',
  };

  const job: JobInput = {
    requiredSkills: Array.from({ length: 80 }, (_, i) => `skill-${i}`),
    preferredSkills: [],
    requiredExperienceYears: 3,
    requiredEducationLevel: 'bachelor',
    title: 'Senior Software Engineer',
    description: 'We are looking for a senior engineer with strong backend skills.',
  };

  const context: ScoringContext = {
    tenantId: 'benchmark-tenant',
    jobId: 'benchmark-job',
    resumeId: 'benchmark-resume',
  };

  const memBefore = process.memoryUsage().heapUsed;
  const startAll = performance.now();

  /**
   * NOTE ON CONCURRENCY:
   * scoreResumeAgainstJob is synchronous and CPU-bound. In a single Node.js
   * process, there is no true parallelism â€” all calls run on the same thread.
   * Promise.all here measures single-threaded throughput with microtask overhead,
   * NOT simulated concurrent request handling.
   *
   * For true concurrency benchmarking at 1M users:
   * - Use k6, autocannon, or wrk against the running Fastify server
   * - Or spawn worker_threads, each running a batch of scoreResumeAgainstJob calls
   *
   * What this benchmark DOES measure accurately:
   * - Pure engine CPU time per invocation (p50/p95/p99 latency)
   * - Memory allocation per batch
   * - Whether the engine is safe to run in tight loops without GC pressure
   */
  for (let offset = 0; offset < iterations; offset += batchSize) {
    const batchCount = Math.min(batchSize, iterations - offset);
    const batchPromises: Promise<void>[] = [];

    for (let i = 0; i < batchCount; i += 1) {
      const p = (async () => {
        const start = performance.now();
        scoreResumeAgainstJob(resume, job, context);
        const end = performance.now();
        latencies.push(end - start);
      })();

      batchPromises.push(p);
    }

    // eslint-disable-next-line no-await-in-loop
    await Promise.all(batchPromises);
  }

  const totalDurationMs = performance.now() - startAll;

  latencies.sort((a, b) => a - b);

  const p50 = latencies[Math.floor(latencies.length * 0.5)] ?? 0;
  const p95 = latencies[Math.floor(latencies.length * 0.95)] ?? 0;
  const p99 = latencies[Math.floor(latencies.length * 0.99)] ?? 0;

  const throughput = iterations / (totalDurationMs / 1000);

  const memAfter = process.memoryUsage().heapUsed;
  const memDeltaMb = ((memAfter - memBefore) / 1024 / 1024).toFixed(1);

  // eslint-disable-next-line no-console
  console.log(`âœ… Benchmark: ${iterations.toLocaleString()} requests`);
  // eslint-disable-next-line no-console
  console.log(`â±  p50: ${p50.toFixed(2)}ms | p95: ${p95.toFixed(2)}ms | p99: ${p99.toFixed(2)}ms`);
  // eslint-disable-next-line no-console
  console.log(`ðŸš€ Throughput: ~${throughput.toFixed(0)} req/s (pure engine, no I/O)`);
  // eslint-disable-next-line no-console
  console.log(`ðŸ§  Memory delta: +${memDeltaMb} MB (heap used during benchmark)`);
}

if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  runBenchmark().catch((err) => {
    // eslint-disable-next-line no-console
    console.error('Benchmark failed', err);
    process.exit(1);
  });
}



===== FILE: ./src/modules/scoring/scoring.cache.ts =====
import crypto from 'crypto';
import { LRUCache } from 'lru-cache';
import type Redis from 'ioredis';
import { CACHE_TTL_SECONDS, MAX_KEYWORDS, REDIS_KEY_PREFIX, SCORING_VERSION } from '@/modules/scoring/scoring.constants';
import type { ResumeInput, ScoringResult } from '@/modules/scoring/scoring.types';

// TTL matches Redis L2 TTL so L1 and L2 expire in sync.
// ttl is in milliseconds for lru-cache v10.
const lru = new LRUCache<string, ScoringResult>({
  max: 1000,
  ttl: CACHE_TTL_SECONDS * 1000,
  ttlAutopurge: false,
});

/**
 * Compute a deterministic, order-independent hash for a resume.
 *
 * @param resume - Resume input to hash.
 * @returns Hex-encoded SHA-256 hash string.
 * @pure
 */
export function computeResumeHash(resume: ResumeInput): string {
  // Deep-clone and sort only the fields that can affect cache identity.
  const sortedSkills = Array.isArray(resume.skills)
    ? [...resume.skills].slice(0, MAX_KEYWORDS).map((s) => s.toLowerCase()).sort()
    : [];

  const sortedCerts = Array.isArray(resume.certifications)
    ? [...resume.certifications].map((s) => s.toLowerCase()).sort()
    : undefined;

  const sortedProjects = Array.isArray(resume.projects)
    ? [...resume.projects].map((s) => s.toLowerCase()).sort()
    : undefined;

  const sortedPublications = Array.isArray(resume.publications)
    ? [...resume.publications].map((s) => s.toLowerCase()).sort()
    : undefined;

  const sortedAwards = Array.isArray(resume.awards)
    ? [...resume.awards].map((s) => s.toLowerCase()).sort()
    : undefined;

  const sortedRoles = Array.isArray(resume.experience?.roles)
    ? [...resume.experience.roles].map((s) => s.toLowerCase()).sort()
    : undefined;

  // Build a canonical object with sorted keys and sorted arrays so that
  // JSON.stringify output is stable regardless of input ordering.
  const canonical = {
    awards: sortedAwards,
    certifications: sortedCerts,
    education: resume.education
      ? { field: resume.education.field?.toLowerCase(), level: resume.education.level }
      : undefined,
    experience: resume.experience
      ? { roles: sortedRoles, years: resume.experience.years }
      : undefined,
    projects: sortedProjects,
    publications: sortedPublications,
    skills: sortedSkills,
    summary: resume.summary?.toLowerCase(),
  };

  const json = JSON.stringify(canonical);
  return crypto.createHash('sha256').update(json).digest('hex');
}

/**
 * Build the cache key for a scoring result.
 *
 * Key format:
 * {tenantId}:smarthire:ats:{jobId}:{hash}
 *
 * @param tenantId - Tenant identifier.
 * @param jobId - Job identifier.
 * @param resumeHash - Deterministic resume hash.
 * @returns Redis cache key string.
 * @pure
 */
function buildCacheKey(tenantId: string, jobId: string, resumeHash: string): string {
  return `{${tenantId}}:${REDIS_KEY_PREFIX}:${jobId}:${resumeHash}:${SCORING_VERSION}`;
}

/**
 * Retrieve a cached scoring result from L1 (in-process) or L2 (Redis).
 *
 * @param redis - Redis client instance.
 * @param tenantId - Tenant identifier.
 * @param jobId - Job identifier.
 * @param resume - Resume input.
 * @returns Cached result or null on miss or error.
 */
export async function getCachedScore(
  redis: Redis,
  tenantId: string,
  jobId: string,
  resume: ResumeInput,
): Promise<ScoringResult | null> {
  const hash = computeResumeHash(resume);
  const key = buildCacheKey(tenantId, jobId, hash);

  const l1 = lru.get(key);
  if (l1) {
    return { ...l1, metadata: { ...l1.metadata, cacheHit: true } };
  }

  try {
    const raw = await redis.get(key);
    if (!raw) {
      return null;
    }

    const parsed = JSON.parse(raw) as ScoringResult;
    lru.set(key, parsed);
    return { ...parsed, metadata: { ...parsed.metadata, cacheHit: true } };
  } catch {
    return null;
  }
}

/**
 * Store a scoring result in both L1 and L2 caches.
 *
 * @param redis - Redis client instance.
 * @param tenantId - Tenant identifier.
 * @param jobId - Job identifier.
 * @param resume - Resume input.
 * @param result - Scoring result to cache.
 */
export async function setCachedScore(
  redis: Redis,
  tenantId: string,
  jobId: string,
  resume: ResumeInput,
  result: ScoringResult,
): Promise<void> {
  const hash = computeResumeHash(resume);
  const key = buildCacheKey(tenantId, jobId, hash);

  lru.set(key, result);

  const jitter = Math.floor(Math.random() * 180);
  const ttl = CACHE_TTL_SECONDS + jitter;

  try {
    await redis.set(key, JSON.stringify(result), 'EX', ttl);
  } catch {
    // Cache errors are non-fatal by design.
  }
}

/**
 * Invalidate all cached scores for a given job within a tenant.
 *
 * @param redis - Redis client instance.
 * @param tenantId - Tenant identifier.
 * @param jobId - Job identifier.
 */
export async function invalidateJobCache(
  redis: Redis,
  tenantId: string,
  jobId: string,
): Promise<void> {
  const pattern = `{${tenantId}}:${REDIS_KEY_PREFIX}:${jobId}:*`;

  // Best-effort invalidation using SCAN to avoid KEYS in production.
  try {
    let cursor = '0';
    do {
      // eslint-disable-next-line no-await-in-loop
      const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', pattern, 'COUNT', 100);
      cursor = nextCursor;

      if (keys.length > 0) {
        // eslint-disable-next-line no-await-in-loop
        await redis.del(...keys);
        keys.forEach((key) => lru.delete(key));
      }
    } while (cursor !== '0');
  } catch {
    // Degraded mode: ignore cache invalidation failures.
  }
}



===== FILE: ./src/modules/scoring/scoring.constants.ts =====
/**
 * Scoring engine constants and configuration.
 *
 * All numeric weights, limits, and version identifiers used by the ATS
 * scoring engine are centralized here to avoid magic numbers elsewhere.
 */

/** Version identifier for the ATS scoring engine. */
export const SCORING_VERSION = 'v1.0.0';

/**
 * Top-level weight distribution for each scoring component.
 *
 * The weights must always sum to 1.0.
 */
export const SCORE_WEIGHTS = {
  skill: 0.4,
  experience: 0.2,
  education: 0.2,
  completeness: 0.1,
  bonus: 0.1,
} as const;

/**
 * Ordered education level map used for ordinal comparisons.
 *
 * Higher numeric values represent higher education levels.
 */
export const EDUCATION_LEVELS = {
  none: 0,
  associate: 1,
  bachelor: 2,
  master: 3,
  phd: 4,
} as const;

/** Required resume sections used for completeness scoring. */
export const REQUIRED_RESUME_SECTIONS = ['skills', 'experience', 'education', 'summary'] as const;

/** Optional resume sections that contribute to the bonus score. */
export const BONUS_ITEMS = ['certifications', 'projects', 'publications', 'awards'] as const;

/** Maximum bonus contribution per bonus item (fraction of total score). */
export const MAX_BONUS_PER_ITEM = 0.025;

/** Maximum aggregate bonus contribution (fraction of total score). */
export const MAX_TOTAL_BONUS = 0.1;

/**
 * Experience thresholds (in years) used for categorizing candidates.
 *
 * These are not directly exposed but useful for future heuristics.
 */
export const EXPERIENCE_THRESHOLDS = {
  junior: 2,
  mid: 4,
  senior: 7,
} as const;

/** Maximum payload size per textual field in bytes (64 KiB). */
export const MAX_PAYLOAD_BYTES = 65_536;

/** TTL for cached scoring results in seconds (1 hour). */
export const CACHE_TTL_SECONDS = 3_600;

/** Redis key prefix used for all ATS scoring-related keys. */
export const REDIS_KEY_PREFIX = 'smarthire:ats';

/** Maximum number of keywords processed per request. */
export const MAX_KEYWORDS = 200;



===== FILE: ./src/modules/scoring/scoring.errors.ts =====
import { AppError } from '@/shared/errors';

/**
 * Error thrown when scoring input validation fails.
 */
export class ScoringValidationError extends AppError {
  /**
   * @param message - Human-readable error message.
   */
  constructor(message: string) {
    super(message, 400);
  }
}

/**
 * Error representing an unexpected failure inside the scoring engine.
 */
export class ScoringEngineError extends AppError {
  /**
   * @param message - Human-readable error message.
   */
  constructor(message: string) {
    super(message, 500);
  }
}

/**
 * Error representing a degraded cache layer. Requests should still succeed,
 * but this error can be used to signal partial outages.
 */
export class ScoringCacheError extends AppError {
  /**
   * @param message - Human-readable error message.
   */
  constructor(message: string) {
    super(message, 503);
  }
}

/**
 * Error thrown when a tenant exceeds its scoring quota or rate limit.
 */
export class TenantQuotaExceededError extends AppError {
  /**
   * @param message - Human-readable error message.
   */
  constructor(message: string) {
    super(message, 429);
  }
}



===== FILE: ./src/modules/scoring/scoring.middleware.ts =====
import type { FastifyReply, FastifyRequest } from 'fastify';
import { MAX_PAYLOAD_BYTES } from '@/modules/scoring/scoring.constants';
import { TenantQuotaExceededError, ScoringValidationError } from '@/modules/scoring/scoring.errors';
import { redis } from '@/infrastructure/redis/redis.client';

// Atomic Lua script: increment a counter and set its TTL only on first increment.
// Returns the current count after increment. This avoids INCR + EXPIRE TOCTOU races.
const RATE_LIMIT_LUA = `
  local current = redis.call('INCR', KEYS[1])
  if current == 1 then
    redis.call('EXPIRE', KEYS[1], ARGV[1])
  end
  return current
`;

/**
 * Guard to reject requests with payloads that exceed 128KB.
 *
 * @param request - Fastify request.
 * @param reply - Fastify reply.
 * @returns Promise resolving when validation is complete.
 */
export async function payloadSizeGuard(request: FastifyRequest, _reply: FastifyReply): Promise<void> {
  const contentLengthHeader = (request as any).headers['content-length'];
  const maxBytes = MAX_PAYLOAD_BYTES * 2;

  if (contentLengthHeader) {
    const contentLength = Number(contentLengthHeader);
    if (Number.isFinite(contentLength) && contentLength > maxBytes) {
      throw new ScoringValidationError('Request payload too large');
    }
  }

  if ((request as any).body) {
    const bodyString = JSON.stringify((request as any).body);
    const size = Buffer.byteLength(bodyString, 'utf8');
    if (size > maxBytes) {
      throw new ScoringValidationError('Request payload too large');
    }
  }
}

/**
 * Middleware to ensure tenant context is present and attaches it to the request.
 *
 * @param request - Fastify request.
 * @param _reply - Fastify reply.
 * @returns Promise resolving when context is attached.
 */
export async function tenantContextMiddleware(
  request: FastifyRequest,
  _reply: FastifyReply,
): Promise<void> {
  const tenantId = request.user?.tenantId;

  if (!tenantId || typeof tenantId !== 'string' || tenantId.trim().length === 0) {
    throw new ScoringValidationError('Missing tenant context');
  }

  request.scoringContext = {
    tenantId,
    jobId: '',
    resumeId: '',
  };
}

/**
 * Redis-backed per-tenant rate limiting hook for scoring operations.
 *
 * RATE LIMITING STRATEGY:
 * - Use @fastify/rate-limit with Redis store (not in-memory â€” stateless/horizontal safe)
 * - Key: `rl:scoring:{tenantId}` â€” per-tenant, not per-IP
 * - Window: 60s, max: 100 requests
 * - Exceeding returns 429 with Retry-After header
 * - Burst allowance: 20 extra requests with 2x penalty TTL
 * - Bypass: internal service tokens (X-Internal-Token header) skip rate limit
 *
 * @param request - Fastify request.
 * @param reply - Fastify reply.
 * @returns Promise resolving when rate limit check passes.
 */
export async function scoringRateLimitHook(
  request: FastifyRequest,
  reply: FastifyReply,
): Promise<void> {
  const tenantId = request.scoringContext?.tenantId ?? request.user?.tenantId;

  if (!tenantId) {
    throw new ScoringValidationError('Missing tenant context for rate limiting');
  }

  // Validate internal service bypass â€” compare against env secret, not just presence.
  const internalToken = (request as any).headers['x-internal-token'];
  const internalSecret = process.env['INTERNAL_SERVICE_SECRET'];
  if (internalSecret && typeof internalToken === 'string' && internalToken === internalSecret) {
    return;
  }

  const key = `rl:scoring:${tenantId}`;
  const windowSeconds = 60;
  const maxRequests = 100;
  const burstAllowance = 20;

  let current: number;

  try {
    const result = await redis.eval(RATE_LIMIT_LUA, 1, key, String(windowSeconds));
    current = Number(result);
  } catch (redisError) {
    (request as any).log?.warn({ err: redisError, tenantId }, 'rate-limit Redis eval failed; allowing request');
    return;
  }

  if (current > maxRequests + burstAllowance) {
    (reply as any).header('Retry-After', String(windowSeconds));
    throw new TenantQuotaExceededError('Scoring rate limit exceeded for tenant');
  }

  if (current > maxRequests && current <= maxRequests + burstAllowance) {
    void redis.expire(key, windowSeconds * 2).catch(() => undefined);
  }
}



===== FILE: ./src/modules/scoring/scoring.routes.ts =====
import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';
import crypto from 'crypto';
import { redis } from '@/infrastructure/redis/redis.client';
import { scoreResume } from '@/modules/scoring/scoring.service';
import { ScoreRequestSchema } from '@/modules/scoring/scoring.schema';
import type { JobInput, ScoringContext } from '@/modules/scoring/scoring.types';
import { SCORING_VERSION } from '@/modules/scoring/scoring.constants';
import { scoringRateLimitHook, tenantContextMiddleware } from '@/modules/scoring/scoring.middleware';

/**
 * Build a deterministic job identifier from job content.
 *
 * @param job - Job input object.
 * @returns Hex-encoded job identifier.
 */
function computeJobId(job: JobInput): string {
  const ordered: Record<string, unknown> = {};
  const keys = Object.keys(job).sort();
  for (const key of keys) {
    ordered[key] = (job as unknown as Record<string, unknown>)[key];
  }

  const json = JSON.stringify(ordered);
  return crypto.createHash('sha256').update(json).digest('hex').slice(0, 16);
}

/**
 * Format Zod validation errors into a field-level error map.
 *
 * @param issues - Zod issues array.
 * @returns Map of field -> list of messages.
 */
function formatZodErrors(issues: { path: (string | number)[]; message: string }[]): Record<string, string[]> {
  const result: Record<string, string[]> = {};

  for (const issue of issues) {
    const field = issue.path.join('.') || 'root';
    if (!result[field]) {
      result[field] = [];
    }
    result[field].push(issue.message);
  }

  return result;
}

/**
 * Fastify route plugin for the scoring engine.
 *
 * Mount point: POST /api/v1/scoring/score
 *
 * @param fastify - Fastify instance.
 */
export default async function scoringRoutes(fastify: FastifyInstance): Promise<void> {
  // bodyLimit operates at stream level â€” rejects oversized payloads before any
  // JSON parsing occurs, preventing heap allocation of malicious bodies.
  // 131_072 = 128KB = 2 Ã— MAX_PAYLOAD_BYTES (envelope overhead included).
  (fastify as any).post(
    '/score',
    {
      bodyLimit: 131_072,
      preHandler: [
        (
          fastify as FastifyInstance & {
            authenticate: (req: FastifyRequest, reply: FastifyReply) => Promise<void>;
          }
        ).authenticate,
        tenantContextMiddleware,
        scoringRateLimitHook,
      ],
    },
    async (request: FastifyRequest, reply: FastifyReply) => {
      const parseResult = ScoreRequestSchema.safeParse((request as any).body);

      if (!parseResult.success) {
        const errors = formatZodErrors(parseResult.error.issues);
        return (reply as any).status(400).send({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Validation failed',
          details: errors,
        });
      }

      const { resume, job } = parseResult.data;

      // tenantId is injected by auth + tenantContextMiddleware â€” never from the body.
      const tenantId = request.user?.tenantId as string;
      const jobId = computeJobId(job);
      const resumeId = crypto.createHash('sha256').update(JSON.stringify(resume)).digest('hex').slice(0, 16);

      const context: ScoringContext = {
        tenantId,
        jobId,
        resumeId,
      };

      const logger = (request as any).log;

      const result = await scoreResume(redis, resume, job, context, logger);

      (reply as any).header('X-Score-Version', SCORING_VERSION);
      (reply as any).header('X-Cache-Hit', String(result.metadata.cacheHit));

      logger.info(
        {
          tenantId,
          jobId,
          score: result.score,
          processingTimeMs: result.metadata.processingTimeMs,
          cacheHit: result.metadata.cacheHit,
        },
        'scoring.completed',
      );

      return (reply as any).status(200).send(result);
    },
  );
}



===== FILE: ./src/modules/scoring/scoring.schema.ts =====
import { z } from 'zod';
import { MAX_KEYWORDS, MAX_PAYLOAD_BYTES } from '@/modules/scoring/scoring.constants';

/**
 * Resume input schema used by the scoring engine.
 */
export const ResumeInputSchema = z.object({
  skills: z.array(z.string().max(200)).max(MAX_KEYWORDS),
  experience: z.object({
    years: z.number().min(0).max(60),
    roles: z.array(z.string().max(500)).max(50).optional(),
  }),
  education: z.object({
    level: z.enum(['none', 'associate', 'bachelor', 'master', 'phd']),
    field: z.string().max(200).optional(),
  }),
  summary: z.string().max(MAX_PAYLOAD_BYTES).optional(),
  certifications: z.array(z.string().max(200)).max(50).optional(),
  projects: z.array(z.string().max(500)).max(50).optional(),
  publications: z.array(z.string().max(500)).max(20).optional(),
  awards: z.array(z.string().max(200)).max(20).optional(),
});

/**
 * Job input schema used by the scoring engine.
 */
export const JobInputSchema = z.object({
  requiredSkills: z.array(z.string().max(200)).min(1).max(MAX_KEYWORDS),
  preferredSkills: z.array(z.string().max(200)).max(MAX_KEYWORDS).optional(),
  requiredExperienceYears: z.number().min(0).max(50),
  requiredEducationLevel: z.enum(['none', 'associate', 'bachelor', 'master', 'phd']),
  title: z.string().max(500),
  description: z.string().max(MAX_PAYLOAD_BYTES).optional(),
});

/**
 * Route body schema for scoring requests.
 *
 * tenantId is injected from JWT and never accepted from the body.
 */
export const ScoreRequestSchema = z.object({
  resume: ResumeInputSchema,
  job: JobInputSchema,
});

export type ResumeInput = z.infer<typeof ResumeInputSchema>;
export type JobInput = z.infer<typeof JobInputSchema>;
export type ScoreRequest = z.infer<typeof ScoreRequestSchema>;



===== FILE: ./src/modules/scoring/scoring.service.ts =====
import type Redis from 'ioredis';
import pino from 'pino';
import { performance } from 'node:perf_hooks';
import { SCORING_VERSION } from '@/modules/scoring/scoring.constants';
import { scoreResumeAgainstJob } from '@/modules/scoring/ats.engine';
import { getCachedScore, setCachedScore } from '@/modules/scoring/scoring.cache';
import type { JobInput, ResumeInput, ScoringContext, ScoringResult } from '@/modules/scoring/scoring.types';

/**
 * Score a resume against a job using the pure engine and cache orchestration.
 *
 * @param redis - Redis client instance.
 * @param resume - Resume input.
 * @param job - Job input.
 * @param context - Scoring context including tenant, jobId, and resumeId.
 * @param logger - Pino logger instance for structured logging.
 * @returns Full scoring result with metadata.
 */
export async function scoreResume(
  redis: Redis,
  resume: ResumeInput,
  job: JobInput,
  context: ScoringContext,
  logger: pino.Logger,
): Promise<ScoringResult> {
  try {
    const cached = await getCachedScore(redis, context.tenantId, context.jobId, resume);
    if (cached) {
      return {
        ...cached,
        metadata: {
          ...cached.metadata,
          cacheHit: true,
        },
      };
    }
  } catch (error) {
    logger.warn(
      { err: error, tenantId: context.tenantId, jobId: context.jobId },
      'Scoring cache lookup failed',
    );
  }

  const start = performance.now();

  try {
    const engineResult = scoreResumeAgainstJob(resume, job, context);

    const processingTimeMs = performance.now() - start;
    const result: ScoringResult = {
      ...engineResult,
      metadata: {
        ...engineResult.metadata,
        processingTimeMs,
        version: SCORING_VERSION,
        cacheHit: false,
      },
    };

    // Fire-and-forget cache write; do not block the response path.
    void setCachedScore(redis, context.tenantId, context.jobId, resume, result).catch((error) => {
      logger.warn(
        { err: error, tenantId: context.tenantId, jobId: context.jobId },
        'Scoring cache write failed',
      );
    });

    return result;
  } catch (error) {
    logger.warn(
      { err: error, tenantId: context.tenantId, jobId: context.jobId },
      'Scoring engine failed',
    );

    const processingTimeMs = performance.now() - start;

    const fallback: ScoringResult = {
      score: 0,
      breakdown: {
        skillScore: 0,
        experienceScore: 0,
        educationScore: 0,
        completenessScore: 0,
        bonusScore: 0,
      },
      matchedKeywords: [],
      missingKeywords: [],
      suggestions: [],
      metadata: {
        processingTimeMs,
        version: SCORING_VERSION,
        cacheHit: false,
      },
    };

    return fallback;
  }
}



===== FILE: ./src/modules/scoring/scoring.types.ts =====
import type { ResumeInput, JobInput } from '@/modules/scoring/scoring.schema';
import type { SCORE_WEIGHTS } from '@/modules/scoring/scoring.constants';

/**
 * Breakdown of individual scoring components.
 */
export interface ScoreBreakdown {
  /** Skill match score (0â€“100). */
  skillScore: number;
  /** Experience relevance score (0â€“100). */
  experienceScore: number;
  /** Education match score (0â€“100). */
  educationScore: number;
  /** Resume completeness score (0â€“100). */
  completenessScore: number;
  /** Bonus feature score (0â€“100). */
  bonusScore: number;
}

/**
 * Metadata emitted by the scoring engine.
 */
export interface ScoringMetadata {
  /** Total processing time in milliseconds (engine + orchestration). */
  processingTimeMs: number;
  /** Version identifier of the scoring engine. */
  version: string;
  /** Indicates whether result was served from cache. */
  cacheHit: boolean;
}

/**
 * Full scoring result returned to API consumers.
 */
export interface ScoringResult {
  /** Final aggregate score, clamped integer in the range 0â€“100. */
  score: number;
  /** Per-component score breakdown. */
  breakdown: ScoreBreakdown;
  /** Normalized, lowercased matched keywords. */
  matchedKeywords: string[];
  /** Normalized, lowercased missing keywords. */
  missingKeywords: string[];
  /** Human-readable improvement suggestions. */
  suggestions: string[];
  /** Engine and processing metadata. */
  metadata: ScoringMetadata;
}

/**
 * Strategy for overriding default component weights on a per-tenant basis.
 *
 * Each property is a fractional weight (e.g. 0.4) and should collectively
 * sum to 1.0 when overrides are applied.
 */
export type WeightStrategy = Partial<Record<keyof typeof SCORE_WEIGHTS, number>>;

/**
 * Scoring context passed alongside inputs, used for cache key derivation
 * and future multi-tenant extensions.
 */
export interface ScoringContext {
  /** Tenant identifier for multi-tenant isolation. */
  tenantId: string;
  /** Logical job identifier; may be derived from job content hash. */
  jobId: string;
  /** Resume identifier for traceability; does not affect scoring. */
  resumeId: string;
  /** Optional weight overrides for this tenant or request. */
  weights?: WeightStrategy;
}

// Re-export input types for convenience and single import point.
export type { ResumeInput, JobInput };



===== FILE: ./src/modules/skills/skills.routes.ts =====
import type { FastifyInstance } from 'fastify';
import * as skillsService from './skills.service';
import { success } from '../../shared/utils/response';

export async function skillsRoutes(fastify: FastifyInstance) {
  const f = fastify as any;
  f.addHook('preHandler', f.authenticate);

  f.get('/gap-analysis', async (request: any, reply: any) => {
    const candidateId = request.user?.sub;
    if (!candidateId) return reply.status(401).send({ error: 'Unauthorized' });
    const roleProfile = (request.query as any)?.roleProfile;
    const data = await skillsService.getGapAnalysis(candidateId, roleProfile);
    return success(reply, data);
  });
}


===== FILE: ./src/modules/skills/skills.service.ts =====
import { prisma } from '../../infrastructure/db/prisma.client';
import { NotFoundError } from '../../shared/errors';

export async function getGapAnalysis(candidateId: string, roleProfile?: string) {
  const candidate = await prisma.candidate.findUnique({
    where: { id: candidateId },
    include: { skillScores: { include: { skill: true } } },
  });
  if (!candidate) throw new NotFoundError('Candidate not found');

  const candidateSkills = candidate.skillScores.map((cs) => cs.skill.name);
  return {
    candidateSkills,
    roleProfile: roleProfile ?? null,
    gaps: [] as string[],
    recommendations: [] as string[],
  };
}


===== FILE: ./src/shared/constants/role-profiles.ts =====
export const ROLE_PROFILES: Record<string, string[]> = {
  'SDE-I': ['Python', 'JavaScript', 'Java', 'React', 'Node.js', 'SQL', 'Git', 'DSA'],
  'SDE-II': ['Python', 'JavaScript', 'TypeScript', 'React', 'Node.js', 'PostgreSQL', 'Docker', 'System Design'],
  'Backend Developer': ['Python', 'Java', 'Node.js', 'PostgreSQL', 'Redis', 'Docker', 'REST APIs'],
  'Frontend Developer': ['JavaScript', 'TypeScript', 'React', 'Git', 'REST APIs'],
  'Full Stack': ['JavaScript', 'TypeScript', 'React', 'Node.js', 'PostgreSQL', 'Docker', 'REST APIs'],
  'QA': ['Java', 'JavaScript', 'SQL', 'Git', 'REST APIs'],
  'DevOps': ['Docker', 'Kubernetes', 'AWS', 'CI/CD', 'Linux', 'Git'],
};


===== FILE: ./src/shared/constants/skill-taxonomy.ts =====
export const SKILL_TAXONOMY = [
  { name: 'Python', slug: 'python', category: 'language', aliases: ['py', 'python3'] },
  { name: 'JavaScript', slug: 'javascript', category: 'language', aliases: ['js', 'es6', 'es2015'] },
  { name: 'TypeScript', slug: 'typescript', category: 'language', aliases: ['ts'] },
  { name: 'Java', slug: 'java', category: 'language', aliases: ['java8', 'java11'] },
  { name: 'C++', slug: 'cpp', category: 'language', aliases: ['c plus plus', 'cplusplus'] },
  { name: 'Go', slug: 'go', category: 'language', aliases: ['golang'] },
  { name: 'React', slug: 'react', category: 'framework', aliases: ['reactjs', 'react.js'] },
  { name: 'Node.js', slug: 'nodejs', category: 'framework', aliases: ['node'] },
  { name: 'Django', slug: 'django', category: 'framework', aliases: [] },
  { name: 'FastAPI', slug: 'fastapi', category: 'framework', aliases: ['fast api'] },
  { name: 'Spring Boot', slug: 'spring-boot', category: 'framework', aliases: ['spring', 'springboot'] },
  { name: 'Express.js', slug: 'express', category: 'framework', aliases: ['express', 'expressjs'] },
  { name: 'PostgreSQL', slug: 'postgresql', category: 'database', aliases: ['postgres', 'pg'] },
  { name: 'MySQL', slug: 'mysql', category: 'database', aliases: [] },
  { name: 'MongoDB', slug: 'mongodb', category: 'database', aliases: ['mongo'] },
  { name: 'Redis', slug: 'redis', category: 'database', aliases: [] },
  { name: 'SQL', slug: 'sql', category: 'database', aliases: ['structured query language'] },
  { name: 'Docker', slug: 'docker', category: 'cloud', aliases: ['containerization'] },
  { name: 'Kubernetes', slug: 'kubernetes', category: 'cloud', aliases: ['k8s'] },
  { name: 'AWS', slug: 'aws', category: 'cloud', aliases: ['amazon web services', 'amazon aws'] },
  { name: 'CI/CD', slug: 'cicd', category: 'cloud', aliases: ['ci cd', 'continuous integration'] },
  { name: 'Git', slug: 'git', category: 'tool', aliases: ['github', 'gitlab', 'version control'] },
  { name: 'REST APIs', slug: 'rest-api', category: 'tool', aliases: ['rest', 'restful', 'api'] },
  { name: 'GraphQL', slug: 'graphql', category: 'tool', aliases: [] },
  { name: 'System Design', slug: 'system-design', category: 'tool', aliases: ['distributed systems', 'hld', 'lld'] },
  { name: 'DSA', slug: 'dsa', category: 'tool', aliases: ['data structures', 'algorithms', 'leetcode'] },
];


===== FILE: ./src/shared/errors.ts =====
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public isOperational: boolean = true
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, public errors?: unknown[]) {
    super(message, 400);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = 'Resource not found') {
    super(message, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden') {
    super(message, 403);
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409);
  }
}


===== FILE: ./src/shared/types/global.d.ts =====
declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      sub: string;
      role: 'candidate' | 'recruiter';
      iat: number;
      exp: number;
      tenantId?: string; // added for scoring module tenant isolation
    };
    scoringContext?: import('@/modules/scoring/scoring.types').ScoringContext;
  }
}


===== FILE: ./src/shared/utils/response.ts =====
type Reply = { status: (code: number) => Reply; send: (body: unknown) => unknown };

export function success<T>(
  reply: Reply,
  data: T,
  statusCode: number = 200,
  message?: string
) {
  return reply.status(statusCode).send({
    status: 'success',
    ...(message && { message }),
    data,
  });
}

export function error(
  reply: Reply,
  message: string,
  statusCode: number = 500,
  errors?: unknown
) {
  const body: Record<string, unknown> = { status: 'error', message };
  if (errors != null) body.errors = errors;
  return reply.status(statusCode).send(body);
}

export function paginated<T>(
  reply: Reply,
  data: T[],
  page: number,
  limit: number,
  total: number
) {
  return reply.send({
    status: 'success',
    data,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  });
}


===== FILE: ./src/worker.ts =====
import 'dotenv/config';
import { resumeParserWorker } from './infrastructure/queue/workers/resume-parser.worker';
import { prisma } from './infrastructure/db/prisma.client';
import { redis } from './infrastructure/redis/redis.client';

console.log('ðŸ“¦ Resume parser worker started');

process.on('SIGTERM', async () => {
  await resumeParserWorker.close();
  await prisma.$disconnect();
  await redis.quit();
  process.exit(0);
});

process.on('SIGINT', async () => {
  await resumeParserWorker.close();
  await prisma.$disconnect();
  await redis.quit();
  process.exit(0);
});


===== FILE: ./tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "node",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


